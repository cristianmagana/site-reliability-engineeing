# MongoDB SRE Interview - Complete Study Guide

## Table of Contents

1. [Interview Overview](#interview-overview)
2. [Linux Fundamentals](#linux-fundamentals)
3. [Networking Fundamentals](#networking-fundamentals)
4. [Troubleshooting Scenarios](#troubleshooting-scenarios)
5. [Essential Commands Reference](#essential-commands-reference)
6. [Common Interview Traps](#common-interview-traps)
7. [Communication Tips](#communication-tips)

---

## Interview Overview

### Format (60 minutes)

- **Coding (30 min)**: Language-agnostic practical problems
- **Linux/Networking (30 min)**: Q&A focused on conceptual understanding

### Linux/Networking Focus

- File systems (inodes, links, permissions)
- Process signals and states
- Shell behavior (globbing, parsing)
- TCP/UDP protocols
- Load balancing
- TLS basics

---

## Linux Fundamentals

### Linux Filesystem Hierarchy Standard (FHS)

The Linux filesystem follows a hierarchical tree structure starting from the root directory `/`. Understanding this structure is essential for system administration and troubleshooting.

#### Root Level Directories

| Directory | Purpose | Characteristics |
|-----------|---------|----------------|
| `/` | Root directory | Top of the filesystem hierarchy |
| `/bin` | Essential user binaries | Commands like `ls`, `cp`, `cat`, `bash` needed for single-user mode |
| `/sbin` | System binaries | System administration commands like `fsck`, `init`, `reboot` |
| `/etc` | Configuration files | System-wide configuration files and shell scripts |
| `/dev` | Device files | Special files representing hardware devices (block/character) |
| `/proc` | Process information | Virtual filesystem providing process and kernel information |
| `/sys` | System information | Virtual filesystem for kernel and device information |
| `/tmp` | Temporary files | Temporary files cleared on reboot (world-writable) |
| `/var` | Variable data | Files that change during system operation |
| `/usr` | User programs | Secondary hierarchy for user utilities and applications |
| `/home` | User home directories | Personal directories for regular users |
| `/root` | Root user home | Home directory for the root user |
| `/lib` | Shared libraries | Essential shared libraries and kernel modules |
| `/boot` | Boot loader files | Kernel, initramfs, and bootloader configuration |
| `/opt` | Optional software | Add-on application software packages |
| `/mnt` | Mount point | Temporary mount point for filesystems |
| `/media` | Removable media | Mount points for removable devices (USB, CD-ROM) |
| `/srv` | Service data | Data for services provided by the system |
| `/run` | Runtime data | Runtime variable data (since boot) |

#### Important Subdirectories

**`/var` subdirectories:**
- `/var/log` - Log files from system and applications
- `/var/spool` - Spool directories (print jobs, cron jobs, mail)
- `/var/tmp` - Temporary files preserved between reboots
- `/var/cache` - Application cache data
- `/var/lib` - State information for applications

**`/usr` subdirectories:**
- `/usr/bin` - Non-essential user binaries
- `/usr/sbin` - Non-essential system binaries
- `/usr/lib` - Libraries for `/usr/bin` and `/usr/sbin`
- `/usr/local` - Locally installed software (tertiary hierarchy)
- `/usr/share` - Architecture-independent shared data
- `/usr/src` - Source code

**`/etc` important files:**
- `/etc/passwd` - User account information
- `/etc/shadow` - Encrypted password information
- `/etc/group` - Group information
- `/etc/hosts` - Static hostname to IP mappings
- `/etc/fstab` - Filesystem mount configuration
- `/etc/resolv.conf` - DNS resolver configuration
- `/etc/ssh/` - SSH daemon configuration
- `/etc/systemd/` - systemd configuration

#### Virtual Filesystems

**`/proc` filesystem:**
- Virtual filesystem exposing kernel and process information
- `/proc/[PID]/` - Per-process information
- `/proc/cpuinfo` - CPU information
- `/proc/meminfo` - Memory information
- `/proc/sys/` - Kernel tunable parameters
- Not stored on disk - generated by kernel at runtime

**`/sys` filesystem:**
- Virtual filesystem exposing kernel objects
- Device information and kernel subsystems
- Used for kernel and device driver interaction
- `/sys/class/` - Device classes (network, block, etc.)
- `/sys/devices/` - Physical device hierarchy

**`/dev` filesystem:**
- Special files representing devices
- Block devices: `/dev/sda`, `/dev/nvme0n1` (storage)
- Character devices: `/dev/tty`, `/dev/null`, `/dev/random`
- Pseudo-devices: `/dev/null`, `/dev/zero`, `/dev/random`
- Managed by `udev` (device manager)

#### Key Concepts

**Filesystem Mounting:**
- Filesystems are attached to directories (mount points)
- `mount` command shows active mounts
- `/etc/fstab` configures automatic mounts at boot
- Root filesystem (`/`) is mounted first, others follow

**Directory Permissions:**
```bash
# Standard directory permissions
drwxr-xr-x  /bin     # 755 - Readable/executable by all
drwxr-xr-x  /etc     # 755 - Readable by all
drwxr-x---  /root    # 750 - Only root access
drwxrwxrwt  /tmp     # 1777 - Sticky bit (only owner can delete)
drwxr-xr-x  /home    # 755 - User homes within
```

**Important Notes:**
- `/bin`, `/sbin`, `/lib` may be symlinks to `/usr/bin`, `/usr/sbin`, `/usr/lib` (merged `/usr` systems)
- `/tmp` and `/var/tmp` differ: `/tmp` cleared on reboot, `/var/tmp` persists
- `/proc` and `/sys` are memory-based - changes don't survive reboot
- The sticky bit on `/tmp` ensures users can only delete their own files

---

### User and Group Management

Linux is a multi-user system where users and groups control access to system resources. User and group information is stored in several files in `/etc`.

#### Core User/Group Files in `/etc`

**`/etc/passwd` - User Account Information**

Contains basic user account information. Each line represents one user account.

**Format:** `username:x:UID:GID:comment:home_directory:shell`

```bash
root:x:0:0:root:/root:/bin/bash
john:x:1001:1001:John Doe:/home/john:/bin/bash
sshd:x:74:74:SSH daemon:/var/empty/sshd:/sbin/nologin
```

**Fields:**
1. **Username** - Login name
2. **Password** - `x` indicates password in `/etc/shadow`
3. **UID** - User ID (0 = root, 1-999 = system, 1000+ = regular users)
4. **GID** - Primary group ID
5. **GECOS/Comment** - Full name and additional info
6. **Home Directory** - User's home directory path
7. **Shell** - Login shell (`/bin/bash`, `/sbin/nologin` for service accounts)

**Permissions:** `-rw-r--r--` (644) - Readable by all, writable by root

---

**`/etc/shadow` - Encrypted Password Information**

Contains encrypted passwords and password aging information. Only accessible by root.

**Format:** `username:encrypted_password:last_change:min:max:warn:inactive:expire:reserved`

```bash
root:$6$randomsalt$hashedpassword:19000:0:99999:7:::
john:$6$randomsalt$hashedpassword:19500:0:99999:7:::
sshd:!!:19000::::::
```

**Fields:**
1. **Username** - Matches `/etc/passwd`
2. **Encrypted Password** - Hashed password (`!!` or `*` = locked account)
3. **Last Changed** - Days since 1970-01-01 when password was last changed
4. **Minimum Days** - Minimum days between password changes (0 = can change anytime)
5. **Maximum Days** - Maximum days password is valid (99999 = no expiry)
6. **Warning Days** - Days before expiry to warn user (typically 7)
7. **Inactive Days** - Days after expiry before account is disabled
8. **Expiration Date** - Days since 1970-01-01 when account expires
9. **Reserved** - Reserved field for future use

**Password Hash Formats:**
- `$1$` - MD5 (legacy, insecure)
- `$5$` - SHA-256
- `$6$` - SHA-512 (most common, recommended)
- `$y$` - yescrypt (newer systems)

**Permissions:** `-rw-------` (600) - Only root can read/write

---

**`/etc/group` - Group Information**

Contains group account information.

**Format:** `group_name:password:GID:user_list`

```bash
root:x:0:
wheel:x:10:john,alice
docker:x:995:john,bob
developers:x:1001:john,alice,carol
```

**Fields:**
1. **Group Name** - Name of the group
2. **Password** - Usually `x` (group passwords rarely used)
3. **GID** - Group ID (0 = root, 1-999 = system, 1000+ = regular groups)
4. **User List** - Comma-separated list of users who are members

**Important Groups:**
- `root` (0) - Root/superuser group
- `wheel` (10) - Administrative users (sudo access on some systems)
- `sudo` (27) - Users with sudo privileges (Debian/Ubuntu)
- `adm` (4) - System monitoring/log viewing
- `disk` (6) - Raw disk access
- `docker` - Docker daemon access

**Permissions:** `-rw-r--r--` (644) - Readable by all

---

**`/etc/gshadow` - Secure Group Information**

Contains secure group account information (group passwords and administrators).

**Format:** `group_name:encrypted_password:administrators:members`

```bash
root:::
wheel:!!::john,alice
docker:!::john,bob
```

**Fields:**
1. **Group Name** - Matches `/etc/group`
2. **Encrypted Password** - Group password (rarely used, usually `!` or `!!`)
3. **Administrators** - Users who can manage the group
4. **Members** - Group members (mirrors `/etc/group`)

**Permissions:** `-rw-------` (600) - Only root can read/write

---

#### User Management Commands

**Creating Users:**

```bash
# Add new user (interactive)
useradd username
useradd -m -s /bin/bash username   # Create home dir, set shell

# Add user with specific UID/GID
useradd -u 1500 -g 1500 username

# Add user with multiple groups
useradd -G docker,sudo,developers username

# Add user with home directory and comment
useradd -m -c "John Doe" -s /bin/bash john

# Add system user (no home, nologin shell)
useradd -r -s /sbin/nologin serviceuser
```

**Modifying Users:**

```bash
# Change user's primary group
usermod -g newgroup username

# Add user to supplementary groups (append)
usermod -aG docker,sudo username

# Change user's home directory
usermod -d /new/home -m username   # -m moves contents

# Change user's shell
usermod -s /bin/zsh username

# Lock/unlock user account
usermod -L username   # Lock
usermod -U username   # Unlock

# Change username
usermod -l newname oldname

# Set account expiration
usermod -e 2025-12-31 username
```

**Deleting Users:**

```bash
# Delete user (keep home directory)
userdel username

# Delete user and home directory
userdel -r username

# Delete user and all files owned by user
userdel -r -f username
```

**Password Management:**

```bash
# Set/change user password (interactive)
passwd username

# Force password change on next login
passwd -e username

# Lock user account
passwd -l username

# Unlock user account
passwd -u username

# View password status
passwd -S username

# Set password aging
chage -M 90 username              # Max 90 days
chage -m 7 username               # Min 7 days between changes
chage -W 14 username              # Warn 14 days before expiry
chage -E 2025-12-31 username      # Account expires on date

# View password aging info
chage -l username
```

---

#### Group Management Commands

**Creating Groups:**

```bash
# Create new group
groupadd groupname

# Create group with specific GID
groupadd -g 1500 groupname

# Create system group
groupadd -r systemgroup
```

**Modifying Groups:**

```bash
# Change group name
groupmod -n newname oldname

# Change group GID
groupmod -g 1600 groupname

# Add user to group
usermod -aG groupname username
# OR
gpasswd -a username groupname

# Remove user from group
gpasswd -d username groupname

# Set group administrators
gpasswd -A admin1,admin2 groupname
```

**Deleting Groups:**

```bash
# Delete group
groupdel groupname
```

**Viewing Group Information:**

```bash
# Show groups for current user
groups

# Show groups for specific user
groups username
id username

# Show all group memberships
id -Gn username

# Show primary group
id -gn username

# List all groups
cat /etc/group
getent group
```

---

#### Important Concepts

**User ID Ranges:**
- **0** - Root user (superuser)
- **1-999** - System/service accounts (daemons, services)
- **1000-65533** - Regular user accounts
- **65534** - `nobody` user (unprivileged operations)

**Primary vs Supplementary Groups:**
- **Primary Group** - User's default group (GID in `/etc/passwd`)
  - Files created by user belong to this group
  - Only one primary group per user
- **Supplementary Groups** - Additional groups user belongs to
  - Listed in `/etc/group` or via `usermod -aG`
  - User can have multiple supplementary groups
  - Grants additional permissions

**Special Files:**
```bash
/etc/skel/          # Template directory for new user homes
/etc/login.defs     # Default user/password configuration
/etc/default/useradd # Default useradd settings
/etc/sudoers        # Sudo configuration (edit with visudo)
/etc/security/      # PAM security configuration
```

**Checking User/Group Information:**

```bash
# User information
id username                    # UID, GID, and groups
finger username                # User details (if installed)
getent passwd username         # Query user database
who                           # Currently logged in users
w                             # Who is logged in and what they're doing
last                          # Login history
lastlog                       # Last login times

# Group information
getent group groupname         # Query group database
lid -g groupname              # List group members (if installed)

# File ownership
ls -l filename                 # Show owner and group
stat filename                  # Detailed file information
find / -user username          # Find all files owned by user
find / -group groupname        # Find all files owned by group
```

**Security Best Practices:**

1. **Never edit `/etc/passwd`, `/etc/shadow`, `/etc/group`, `/etc/gshadow` directly**
   - Use `vipw` for `/etc/passwd` and `/etc/shadow`
   - Use `vigr` for `/etc/group` and `/etc/gshadow`
   - Or use management commands (useradd, usermod, etc.)

2. **Service accounts should not have login shells**
   ```bash
   useradd -r -s /sbin/nologin servicename
   ```

3. **Use strong password policies**
   - Configure in `/etc/login.defs` and `/etc/security/pwquality.conf`
   - Enforce password aging with `chage`

4. **Principle of least privilege**
   - Only grant necessary group memberships
   - Use sudo instead of sharing root password
   - Regularly audit group memberships

5. **Monitor account changes**
   ```bash
   # Watch for changes to user/group files
   auditctl -w /etc/passwd -p wa -k user_changes
   auditctl -w /etc/shadow -p wa -k password_changes
   auditctl -w /etc/group -p wa -k group_changes
   ```

---

### Special Permission Bits (SUID, SGID, Sticky Bit)

Beyond the standard read, write, and execute permissions, Linux has three special permission bits that modify how files and directories behave.

#### The Three Special Bits

| Bit | Name | Octal | Symbol | Applies To | Purpose |
|-----|------|-------|--------|------------|---------|
| SUID | Set User ID | 4000 | `s` in user execute position | Files | Execute as file owner |
| SGID | Set Group ID | 2000 | `s` in group execute position | Files & Directories | Execute as group owner / Inherit directory group |
| Sticky | Sticky Bit | 1000 | `t` in other execute position | Directories | Only owner can delete files |

---

#### SUID (Set User ID) - Octal 4000

**What it does:**
- When a file with SUID is executed, the process runs with the **file owner's permissions**, not the user who ran it
- Only applies to executable files
- Commonly used for programs that need elevated privileges

**Visual indicator:**
```bash
-rwsr-xr-x  # 's' in owner's execute position (SUID set, executable)
-rwSr-xr-x  # 'S' in owner's execute position (SUID set, NOT executable - misconfigured)
```

**Common examples:**

```bash
# passwd command - allows users to change their password
ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root 68208 /usr/bin/passwd

# User runs passwd, but it executes as root to modify /etc/shadow
# Without SUID, regular users couldn't change their passwords

# ping command - needs raw socket access (requires root)
ls -l /usr/bin/ping
-rwsr-xr-x 1 root root 64424 /usr/bin/ping

# sudo command itself
ls -l /usr/bin/sudo
-rwsr-xr-x 1 root root 166056 /usr/bin/sudo
```

**Setting SUID:**

```bash
# Symbolic method
chmod u+s filename
chmod u-s filename    # Remove SUID

# Octal method (4 prefix)
chmod 4755 filename   # -rwsr-xr-x
chmod 4750 filename   # -rwsr-x---

# Example: Create SUID script (dangerous!)
echo '#!/bin/bash' > test.sh
echo 'whoami' >> test.sh
chmod 4755 test.sh
ls -l test.sh
# -rwsr-xr-x 1 root root test.sh

# When any user runs it:
./test.sh
# Output: root  (runs as file owner)
```

**Security implications:**

- **Dangerous if misconfigured** - Can allow privilege escalation
- SUID scripts are ignored on many systems for security
- Only SUID binaries (compiled programs) typically work
- Common attack vector: Find writable SUID files or vulnerable SUID programs

**Finding SUID files:**

```bash
# Find all SUID files on system
find / -perm -4000 -type f 2>/dev/null

# Find SUID files owned by root
find / -user root -perm -4000 -type f 2>/dev/null

# Detailed listing
find / -perm -4000 -type f -ls 2>/dev/null

# Common security check
find / -perm -4000 -type f -exec ls -la {} \; 2>/dev/null
```

---

#### SGID (Set Group ID) - Octal 2000

SGID behaves differently for files vs directories.

**SGID on Files:**

- Process runs with the **file's group permissions** instead of user's group
- Similar to SUID but for group ownership
- Less common than SUID

**Visual indicator:**
```bash
-rwxr-sr-x  # 's' in group's execute position (SGID set, executable)
-rwxr-Sr-x  # 'S' in group's execute position (SGID set, NOT executable)
```

**Example:**

```bash
# Create file with SGID
touch testfile
chgrp developers testfile
chmod 2755 testfile
ls -l testfile
# -rwxr-sr-x 1 user developers testfile

# When executed, runs with 'developers' group privileges
```

**SGID on Directories:**

- **Most useful case**: Files created in directory automatically inherit the directory's group
- Without SGID: New files get creator's primary group
- With SGID: New files get directory's group

**Visual indicator:**
```bash
drwxrwsr-x  # 's' in group execute position on directory
```

**Practical example:**

```bash
# Scenario: Shared project directory for 'developers' group

# Without SGID (problematic)
mkdir project
chgrp developers project
chmod 770 project
# User creates file
touch project/file.txt
ls -l project/file.txt
# -rw-r--r-- 1 user user project/file.txt  # Wrong group!
# Other developers in 'developers' group can't access it

# With SGID (correct)
mkdir shared_project
chgrp developers shared_project
chmod 2770 shared_project    # Set SGID
ls -ld shared_project
# drwxrws--- 2 user developers shared_project

# User creates file
touch shared_project/file.txt
ls -l shared_project/file.txt
# -rw-r--r-- 1 user developers shared_project/file.txt  # Correct group!
# All developers can access it
```

**Setting SGID:**

```bash
# Symbolic method
chmod g+s filename_or_directory
chmod g-s filename_or_directory    # Remove SGID

# Octal method (2 prefix)
chmod 2755 directory    # drwxr-sr-x
chmod 2770 directory    # drwxrws---

# Common pattern for shared directories
mkdir /shared/team
chgrp teamgroup /shared/team
chmod 2775 /shared/team    # rwxrwsr-x
```

**Finding SGID files/directories:**

```bash
# Find all SGID files
find / -perm -2000 -type f 2>/dev/null

# Find all SGID directories
find / -perm -2000 -type d 2>/dev/null

# Find SGID files owned by specific group
find / -group developers -perm -2000 2>/dev/null
```

---

#### Sticky Bit - Octal 1000

**What it does:**
- Only applies to **directories** (no effect on files in modern Linux)
- Prevents users from deleting or renaming files they don't own
- Users can only delete/rename their own files, even if they have write permission to directory

**Visual indicator:**
```bash
drwxrwxrwt  # 't' in others' execute position (sticky bit set, executable)
drwxrwxrwT  # 'T' in others' execute position (sticky bit set, NOT executable)
```

**Primary use case: `/tmp` directory**

```bash
ls -ld /tmp
# drwxrwxrwt 15 root root 4096 /tmp

# All users can write to /tmp (777 permissions)
# But sticky bit prevents users from deleting others' files
```

**Demonstration:**

```bash
# Without sticky bit (dangerous)
mkdir test_dir
chmod 777 test_dir
# User alice creates file
su - alice -c "touch test_dir/alice_file.txt"
# User bob can DELETE alice's file!
su - bob -c "rm test_dir/alice_file.txt"  # Success (bad!)

# With sticky bit (secure)
mkdir secure_dir
chmod 1777 secure_dir    # Set sticky bit
ls -ld secure_dir
# drwxrwxrwt 2 root root secure_dir

# User alice creates file
su - alice -c "touch secure_dir/alice_file.txt"
# User bob CANNOT delete alice's file
su - bob -c "rm secure_dir/alice_file.txt"
# rm: cannot remove 'secure_dir/alice_file.txt': Operation not permitted

# But bob can delete his own files
su - bob -c "touch secure_dir/bob_file.txt"
su - bob -c "rm secure_dir/bob_file.txt"  # Success
```

**Who can delete files in sticky-bit directory:**
1. File owner
2. Directory owner
3. Root user

**Setting Sticky Bit:**

```bash
# Symbolic method
chmod +t directory
chmod -t directory    # Remove sticky bit

# Octal method (1 prefix)
chmod 1777 directory    # drwxrwxrwt
chmod 1775 directory    # drwxrwxr-t

# Typical use case
mkdir /shared/uploads
chmod 1777 /shared/uploads
```

**Finding directories with sticky bit:**

```bash
# Find all directories with sticky bit
find / -type d -perm -1000 2>/dev/null

# Common directories with sticky bit
ls -ld /tmp /var/tmp
# drwxrwxrwt /tmp
# drwxrwxrwt /var/tmp
```

---

#### Combining Special Bits

You can combine multiple special bits using octal notation:

```bash
# Octal format: [special][user][group][other]
# Special bits:
#   4 = SUID
#   2 = SGID
#   1 = Sticky

# Examples:
chmod 4755 file    # SUID only:        -rwsr-xr-x
chmod 2755 dir     # SGID only:        drwxr-sr-x
chmod 1777 dir     # Sticky only:      drwxrwxrwt
chmod 6755 file    # SUID + SGID:      -rwsr-sr-x
chmod 3770 dir     # SGID + Sticky:    drwxrws--t
chmod 7755 file    # All three:        -rwsr-sr-t (rare)
```

---

#### Understanding the Symbols

**Execute permission present:**
- `s` (lowercase) - Special bit set AND execute permission present
- `t` (lowercase) - Sticky bit set AND execute permission present

**Execute permission absent:**
- `S` (uppercase) - Special bit set but NO execute permission (misconfigured)
- `T` (uppercase) - Sticky bit set but NO execute permission (misconfigured)

**Examples:**

```bash
# Properly configured SUID
-rwsr-xr-x  # Owner can execute, SUID works

# Misconfigured SUID (useless)
-rwSr--r--  # Owner cannot execute, SUID doesn't work

# Properly configured sticky bit
drwxrwxrwt  # Others can execute (enter directory), sticky works

# Misconfigured sticky bit
drwxrwxrwT  # Others cannot execute, sticky doesn't work properly
```

---

#### Viewing Special Bits

```bash
# Using ls -l (shows symbolic)
ls -l /usr/bin/passwd
# -rwsr-xr-x  1 root root  68208 /usr/bin/passwd

# Using stat (shows both symbolic and octal)
stat /usr/bin/passwd
# Access: (4755/-rwsr-xr-x)

stat /tmp
# Access: (1777/drwxrwxrwt)

# Using find to show octal permissions
find /usr/bin -name passwd -printf "%m %p\n"
# 4755 /usr/bin/passwd
```

---

#### Security Considerations

**SUID:**
- ⚠️ **High security risk** if misconfigured
- Regularly audit SUID files: `find / -perm -4000 -type f`
- Minimize SUID files on system
- Never set SUID on writable files
- Watch for new SUID files (potential backdoors)

**SGID:**
- ⚠️ **Moderate security risk** on files
- ✅ **Very useful** on directories for collaboration
- Use for shared project directories
- Combine with appropriate group permissions

**Sticky Bit:**
- ✅ **Security enhancement** for world-writable directories
- Always use on directories like `/tmp`
- Prevents file deletion attacks

**Best practices:**

```bash
# Security audit - Find suspicious SUID/SGID files
find / \( -perm -4000 -o -perm -2000 \) -type f -ls 2>/dev/null

# Check for world-writable SUID files (very dangerous!)
find / -perm -4000 -perm -002 -type f 2>/dev/null

# Monitor for new SUID files
find / -perm -4000 -type f 2>/dev/null > /tmp/suid_baseline.txt
# Later, check for changes:
diff /tmp/suid_baseline.txt <(find / -perm -4000 -type f 2>/dev/null)

# Remove unnecessary SUID bits
chmod u-s /path/to/file

# Shared directory best practice
mkdir /shared/team
chgrp team /shared/team
chmod 2770 /shared/team    # SGID, no world access
```

---

#### Common Use Cases Summary

**SUID (4000):**
- System utilities needing root privileges (`passwd`, `sudo`, `ping`)
- Programs that modify system files
- Network utilities requiring raw sockets

**SGID (2000) on files:**
- Programs needing specific group privileges
- Less common than SUID

**SGID (2000) on directories:**
- ✅ **Shared project directories** (most common use case)
- Team collaboration spaces
- Drop directories for specific groups

**Sticky Bit (1000):**
- ✅ **World-writable directories** (`/tmp`, `/var/tmp`)
- Shared upload directories
- Any multi-user writable space needing file protection

---

#### Quick Reference Table

| Permission | Octal | On Files | On Directories |
|------------|-------|----------|----------------|
| SUID | 4000 | Execute as file owner | No effect |
| SGID | 2000 | Execute as file's group | New files inherit directory's group |
| Sticky | 1000 | No effect (modern Linux) | Only owner can delete files |

**Most common combinations:**

```bash
4755  # SUID executable:        -rwsr-xr-x
2770  # SGID shared directory:  drwxrws---
2775  # SGID shared directory:  drwxrwsr-x (with world read)
1777  # Sticky public directory: drwxrwxrwt
```

---

### File System Operations

#### What Happens When You Run `rm filename`

**Process Flow:**

1. Shell locates `rm` binary via $PATH
2. Shell forks, child process exec's `rm`
3. `rm` calls `unlink()` system call
4. Directory entry (linking filename to inode) is removed
5. Inode's link count is decremented
6. If link count = 0 AND no processes have file open:
   - Inode and data blocks marked as free in filesystem bitmaps
7. If processes still have file open:
   - Deletion deferred until last file descriptor closes
8. Data isn't immediately overwritten (why file recovery works)

**Key Points:**

- No signals involved (SIGTERM is for killing processes, not files)
- Filename lives in directory entry, not inode
- Inode contains: metadata, permissions, timestamps, pointers to data blocks

---

#### Hard Links vs Symbolic Links

| Feature                   | Hard Link                         | Symbolic Link (Symlink)             |
| ------------------------- | --------------------------------- | ----------------------------------- |
| **What it is**            | Directory entry pointing to inode | Special file containing path string |
| **Inode**                 | Shares same inode as target       | Has its own inode                   |
| **After deleting target** | Still works (shares inode)        | Becomes "dangling" (broken link)    |
| **Cross filesystem**      | ❌ No (different inode tables)    | ✅ Yes                              |
| **Link to directories**   | ❌ No (prevents cycles)           | ✅ Yes                              |
| **Visibility**            | Looks like regular file           | Shows as lrwxrwxrwx with -> target  |

**Commands:**

```bash
# Hard link
ln file1.txt file2.txt
ls -i file1.txt file2.txt  # Same inode number

# Symbolic link
ln -s file1.txt file2_link
ls -i file1.txt file2_link  # Different inode numbers
```

**When target is deleted:**

- **Hard link**: Continues to work (both are equal directory entries)
- **Symlink**: Breaks (path no longer exists)

---

#### Recovering from `chmod 000 /bin/chmod`

**Problem:** Even root cannot execute a file with no execute permissions.

**Solutions (in order of preference):**

```bash
# Method 1: Use Python (quickest)
python3 -c "import os; os.chmod('/bin/chmod', 0o755)"

# Method 2: Use Perl
perl -e 'chmod 0755, "/bin/chmod"'

# Method 3: Use busybox
busybox chmod 755 /bin/chmod

# Method 4: Use install command
install -m 755 /bin/chown /tmp/chmod_backup
install -m 755 /tmp/chmod_backup /bin/chmod

# Method 5: Copy from another location
cp /usr/bin/chmod /bin/chmod  # If available elsewhere
```

**Why this works:** Interpreted languages call `chmod()` system call directly without needing to execute the `/bin/chmod` binary.

---

### Process Management

#### Process States

| State                      | Symbol | Description                            | Can Kill?            |
| -------------------------- | ------ | -------------------------------------- | -------------------- |
| Running                    | R      | Executing or ready to run              | ✅ Yes               |
| Sleeping (Interruptible)   | S      | Waiting for event, can be interrupted  | ✅ Yes               |
| Sleeping (Uninterruptible) | D      | Waiting for I/O, cannot be interrupted | ❌ No                |
| Zombie                     | Z      | Terminated but not reaped by parent    | ❌ No (already dead) |
| Stopped                    | T      | Paused by signal (SIGSTOP/SIGTSTP)     | ✅ Yes               |

#### The D State Problem

**What it means:**

- Process stuck in kernel space waiting for I/O
- Cannot receive signals (including SIGKILL)
- Usually lasts milliseconds; hours = serious problem

**Common Causes:**

1. **Hung NFS mount** (most common)
2. Failing disk hardware
3. Overloaded storage backend
4. Kernel bug or driver issue

**Investigation Steps:**

```bash
# 1. Find processes in D state
ps aux | awk '$8 ~ /D/ {print}'
ps -eo pid,stat,comm,wchan | grep "^[0-9]* D"

# 2. Check what it's waiting for (WCHAN column)
# Common values:
# - nfs_sync_inode_wait: NFS issue
# - wait_on_page_writeback: Disk write
# - io_schedule: Generic I/O wait

# 3. See what files are open
sudo lsof -p <PID>

# 4. Check kernel stack trace
sudo cat /proc/<PID>/stack

# 5. I/O investigation
iostat -x 1 5    # Look for %util at 100%, high await
sudo iotop -o    # Per-process I/O
cat /proc/<PID>/io

# 6. Check mount points
mount | grep nfs
timeout 5 ls -l /nfs/mount/point  # Test if responsive
dmesg | grep -i "stale\|nfs"

# 7. Hardware issues
dmesg | grep -i "error\|fail\|ata\|scsi"
sudo smartctl -a /dev/sda
```

**Can you kill it?**

- **Direct answer: NO**
- Signals only delivered when process returns to user space
- Process is stuck in kernel space

**Solutions:**

```bash
# Fix the underlying I/O issue
sudo umount -f /nfs/mount   # Force unmount NFS
sudo umount -l /nfs/mount   # Lazy unmount

# For NFS, use soft mounts in future
mount -t nfs -o soft,timeo=10,intr server:/export /mnt

# Last resort: Reboot (but fix root cause!)
```

---

#### Signals

| Signal  | Number | Default Action | Can Catch? | Use Case                       |
| ------- | ------ | -------------- | ---------- | ------------------------------ |
| SIGTERM | 15     | Terminate      | ✅ Yes     | Graceful shutdown (default)    |
| SIGKILL | 9      | Terminate      | ❌ No      | Force kill                     |
| SIGSTOP | 19     | Stop           | ❌ No      | Pause process                  |
| SIGCONT | 18     | Continue       | ✅ Yes     | Resume stopped process         |
| SIGTSTP | 20     | Stop           | ✅ Yes     | Ctrl+Z (can catch for cleanup) |
| SIGINT  | 2      | Terminate      | ✅ Yes     | Ctrl+C (interrupt)             |
| SIGHUP  | 1      | Terminate      | ✅ Yes     | Hangup / reload config         |

**Important Corrections:**

- **SIGINT does NOT pause** - it requests termination
- **SIGSTOP/SIGTSTP pause** processes
- **SIGTERM is graceful**, SIGKILL is forceful

**Commands:**

```bash
kill -l                    # List all signals
kill PID                   # SIGTERM (default, graceful)
kill -TERM PID            # Same as above
kill -KILL PID            # Force kill (cannot be caught)
kill -9 PID               # Same as SIGKILL
kill -STOP PID            # Pause
kill -CONT PID            # Resume
kill -HUP PID             # Reload config (many daemons support this)

# Process groups (negative PID)
kill -TERM -1234          # Kill entire process group 1234
```

---

#### Process Group Signals

**Difference between `kill PID` and `kill -PID`:**

```bash
# kill PID: Send signal to single process
kill -TERM 1234

# kill -PID: Send signal to entire process group
kill -TERM -1234

# This kills parent AND all children with same PGID
```

**When to use process groups:**

- Killing parent with all children (shell scripts with subprocesses)
- Stopping entire job (terminal job control)
- Related to terminal sessions and `nohup`

**Terminal sessions:**

```bash
# When you logout, terminal sends SIGHUP to session leader
# Session leader forwards to process group
# All processes in group receive SIGHUP

# nohup protects from this:
nohup ./long_running_script.sh &
# Process ignores SIGHUP, survives logout

# Alternative: disown
./script.sh &
disown

# Or use screen/tmux
screen -S mysession
# Detach with Ctrl+A, D
# Reattach with: screen -r mysession
```

---

#### Investigating High CPU Usage

**Systematic Approach:**

```bash
# Step 1: Identify the process
top -o %CPU
htop
ps aux --sort=-%cpu | head -n 10

# Note: %CPU can exceed 100% on multi-core
# 400% = using 4 cores fully

# Step 2: Get process details
cat /proc/PID/status
cat /proc/PID/cmdline | tr '\0' ' '
ps -p PID -o args

# Step 3: Understand what it's doing
strace -c -p PID  # System call summary
# High CPU with few syscalls = pure computation/infinite loop

# Step 4: Stack trace
pstack PID           # C/C++
jstack PID           # Java
py-spy dump -p PID   # Python

# Step 5: Check threads
ps -T -p PID
top -H -p PID
cat /proc/PID/task/*/status | grep -E "^(Name|State):"

# Step 6: Profile the application
perf top -p PID
perf record -p PID -g
perf report

# Step 7: Check system resources
vmstat 1
# us = user CPU, sy = system CPU
# id = idle, wa = I/O wait

mpstat -P ALL 1      # Per-core CPU
pidstat -w -p PID 1  # Context switches
iotop -p PID         # I/O activity
```

**Common Causes:**

- Infinite loop or logic bug (high CPU, minimal syscalls)
- Inefficient algorithm (O(n²) processing large dataset)
- Busy-wait polling loop
- Lock contention in multi-threaded app

---

### Disk Space Issues

#### Disk Full but `df -h` Shows Space

**Common Scenarios:**

**1. Deleted Files Still Open (Most Common)**

```bash
# Problem: File deleted but process still has it open
# df counts it, du doesn't see it

# Find them:
lsof +L1
lsof | grep deleted

# Example output:
# java  1234  app  10w  REG  253,1  5.0G  0  /var/log/app.log (deleted)

# Solutions:
# Option 1: Restart the process
systemctl restart application

# Option 2: Truncate the file descriptor
truncate -s 0 /proc/PID/fd/FD_NUMBER

# Option 3: Send SIGHUP (many daemons reopen logs)
kill -HUP PID
```

**2. Inode Exhaustion**

```bash
# Check inode usage
df -i

# Output showing problem:
# Filesystem      Inodes   IUsed   IFree IUse% Mounted on
# /dev/sda1      3276800 3276800       0  100% /

# Find directories with most files:
for dir in /*; do
  echo -n "$dir: ";
  find "$dir" -type f | wc -l;
done | sort -t: -k2 -n

# Or:
find / -xdev -printf '%h\n' | sort | uniq -c | sort -k 1 -n
```

**3. Reserved Blocks**

```bash
# Ext filesystems reserve ~5% for root
tune2fs -l /dev/sda1 | grep -i "reserved block"

# Non-root users see "disk full"
# Root sees available space
```

**4. Hidden Mount Points**

```bash
# Data written before mount is hidden but uses space
echo "hidden" > /mnt/test.txt
mount /dev/sdb1 /mnt    # Hides test.txt

# To find:
umount /mnt
ls /mnt                 # Now you see hidden files
```

**Debugging Script:**

```bash
#!/bin/bash
# Quick disk space diagnostic

echo "=== Disk Space ==="
df -h /

echo -e "\n=== Inode Usage ==="
df -i /

echo -e "\n=== Deleted but Open Files ==="
lsof +L1 2>/dev/null | grep -v "0t0" | grep "REG"

echo -e "\n=== Largest Directories ==="
du -sh /* 2>/dev/null | sort -h | tail -10

echo -e "\n=== Compare df vs du ==="
echo "df reports: $(df -h / | tail -1 | awk '{print $3}') used"
echo "du reports: $(du -sh / 2>/dev/null | awk '{print $1}') used"
```

---

## Networking Fundamentals

### TCP Three-Way Handshake

**The Process:**

```
Client                          Server
  |                               |
  |  [1] SYN (seq=X)             |
  |----------------------------->|  State: LISTEN → SYN-RECEIVED
  |  State: SYN-SENT             |
  |                              |
  |  [2] SYN-ACK (seq=Y, ack=X+1)|
  |<-----------------------------|
  |                              |
  |  [3] ACK (seq=X+1, ack=Y+1)  |
  |----------------------------->|
  |                              |
  (State: ESTABLISHED)      (State: ESTABLISHED)
```

**What Each Step Does:**

1. **Client sends SYN:**

   - Includes initial sequence number (ISN) = X
   - Client enters SYN-SENT state
   - "I want to connect, here's my starting sequence"

2. **Server sends SYN-ACK:**

   - Server's sequence number = Y
   - Acknowledgment = X+1
   - Server enters SYN-RECEIVED state
   - "Got your SYN, here's my starting sequence"

3. **Client sends ACK:**
   - Sequence = X+1, Acknowledgment = Y+1
   - Both enter ESTABLISHED state
   - "Got your SYN-ACK, let's send data"

---

#### If SYN-ACK is Lost

**What Happens:**

```
Client                          Server
  |  [1] SYN (seq=X)             |
  |----------------------------->|
  |  [2] SYN-ACK ✗✗✗ LOST ✗✗✗    |
  |                              |
  | ... timeout (1-3 seconds)... | (Server waiting in SYN-RECEIVED)
  |                              |
  |  [1] SYN RETRANSMIT          |
  |----------------------------->|
  |  [2] SYN-ACK                 |
  |<-----------------------------|
  |  [3] ACK                     |
  |----------------------------->|
```

**Key Points:**

- Client's retransmission timer expires
- Client retransmits **the same SYN** (same seq=X)
- Exponential backoff: 1s, 2s, 4s, 8s, 16s, 32s...
- After 5-6 attempts (configurable), gives up
- Server also has timer for missing ACK
- No data flows until handshake completes

**Tuning:**

```bash
# Number of SYN retries before giving up
cat /proc/sys/net/ipv4/tcp_syn_retries  # Default: 6
```

---

### TCP vs UDP

#### TCP Retransmission

**How it Works:**

- TCP is reliable and connection-oriented
- Every segment has a sequence number
- Receiver sends ACKs for received segments
- Sender maintains retransmission timer for unacked segments

**When Retransmission Happens:**

1. **Timeout:** ACK not received before timer expires
2. **Duplicate ACKs:** Receiver sends duplicate ACKs when gap detected
   - 3 duplicate ACKs trigger **fast retransmit**

**What Gets Retransmitted:**

- Exact same segment with same sequence number
- Receiver uses sequence numbers to:
  - Reassemble data in order
  - Detect and discard duplicates

**Performance Impact:**

- Reduces throughput
- TCP adjusts congestion window
- RTT (Round Trip Time) affects retransmission delay

**Causes:**

- Network congestion
- Packet corruption
- Packet loss
- Out-of-order delivery

---

#### UDP Packet Loss

**How it Works:**

- UDP is unreliable and connectionless
- No acknowledgments, no sequence numbers
- No retransmission at transport layer
- Sender has no idea packet was lost

**When Packets Are Lost:**

- Sender doesn't know
- Receiver simply never gets data
- No automatic recovery

**Application Responsibility:**

- If reliability needed, app must implement it
- Examples:
  - **QUIC** (HTTP/3): Reliability over UDP
  - **RTP** (VoIP): Uses sequence numbers but may not retransmit
  - **DNS**: Application-level retry after timeout

**Why Use UDP Despite Loss:**

1. Lower latency (no connection setup, no ACK waiting)
2. Less overhead (8-byte header vs 20+ for TCP)
3. Better for real-time (old data is useless in live video)
4. Multicast/broadcast capable

**Use Cases:**

- DNS queries (retry is fine)
- VoIP/video streaming (some loss acceptable)
- Gaming (speed > perfect accuracy)
- DHCP (simple request/response)

---

### TCP Connection States

| State        | Description                                         |
| ------------ | --------------------------------------------------- |
| LISTEN       | Server waiting for connections                      |
| SYN-SENT     | Client sent SYN, waiting for SYN-ACK                |
| SYN-RECEIVED | Server sent SYN-ACK, waiting for ACK                |
| ESTABLISHED  | Connection active, data flowing                     |
| FIN-WAIT-1   | Sent FIN, waiting for ACK                           |
| FIN-WAIT-2   | Received ACK of FIN, waiting for peer's FIN         |
| TIME-WAIT    | Connection closed, waiting for stray packets (2MSL) |
| CLOSE-WAIT   | Peer closed connection, local not yet closed        |
| LAST-ACK     | Sent FIN after CLOSE-WAIT, waiting for ACK          |
| CLOSING      | Both sides closing simultaneously                   |

**Important States:**

- **CLOSE-WAIT**: Application not closing sockets properly
- **TIME-WAIT**: Normal after connection close (prevents packet confusion)

---

### netstat vs ss

| Feature     | netstat                     | ss                            |
| ----------- | --------------------------- | ----------------------------- |
| Speed       | Slow (reads /proc)          | Fast (netlink sockets)        |
| Data Source | /proc/net/\* files          | Direct kernel query           |
| Performance | Heavy with many connections | Minimal overhead              |
| Status      | Legacy/deprecated           | Actively maintained           |
| Filtering   | Limited (need grep)         | Built-in powerful filters     |
| TCP Details | Basic                       | Detailed (RTT, cwnd, retrans) |

**Basic Usage:**

```bash
# List all TCP/UDP listening ports
netstat -tuln
ss -tuln

# With process information (requires root)
sudo netstat -tulnp
sudo ss -tulnp

# All connections (listening + established)
netstat -tuan
ss -tuan
```

**ss Advanced Features:**

```bash
# Extended TCP information
ss -ti

# Output includes:
# - rto: Retransmission timeout
# - rtt: Round-trip time
# - cwnd: Congestion window
# - bytes_retrans: Retransmitted bytes
# - send rate, delivery rate

# Powerful filtering
ss -tn dst :443                    # Connections to port 443
ss -tn src 192.168.1.100          # From specific IP
ss -tn state established          # Only established
ss -tn state time-wait            # Only TIME-WAIT
ss -tn '( dport = :80 or dport = :443 )' state established

# Summary statistics
ss -s

# Memory usage per socket
ss -tm

# Timers
ss -to
```

**Performance Comparison:**

```bash
# On system with 50,000 connections:
time netstat -tan > /dev/null
# real    0m2.341s

time ss -tan > /dev/null
# real    0m0.123s
```

**When to Use:**

- **netstat:** Legacy systems, quick routing table checks
- **ss:** Modern systems (faster, more powerful), production troubleshooting, detailed TCP metrics

---

## Troubleshooting Scenarios

### Connection Reset by Peer

**What RST Means:**

- TCP RST packet abruptly closes connection
- No graceful FIN handshake
- Connection immediately destroyed

**Common Causes:**

1. Application explicitly closed connection
2. Firewall actively rejecting
3. Connection tracking table full
4. Kernel limits (file descriptors, socket buffers)
5. TCP backlog full

---

#### Diagnostic Flow

**Step 1: Capture the RST**

```bash
# Capture RST packets
sudo tcpdump -i any -nn 'tcp[tcpflags] & tcp-rst != 0' -w rst.pcap

# Specific port
sudo tcpdump -i any -nn port 8080 and 'tcp[tcpflags] & tcp-rst != 0'

# Analyze
tcpdump -r rst.pcap -vvv -nn

# Look for:
# - Which side sent RST (client or server)
# - When in connection lifecycle
# - Sequence number issues
```

**Step 2: Check Application**

```bash
# Application running?
systemctl status myapp
ps aux | grep myapp

# Application logs
journalctl -u myapp -f --since "5 minutes ago"

# Look for:
# - "Connection closed", "Timeout"
# - "Too many connections"
# - Exception traces

# Metrics (if available)
curl http://localhost:8080/metrics
```

**Step 3: Check Connection Tracking**

```bash
# Current count vs maximum
cat /proc/sys/net/netfilter/nf_conntrack_count
cat /proc/sys/net/netfilter/nf_conntrack_max

# Usage percentage
echo "scale=2; $(cat /proc/sys/net/netfilter/nf_conntrack_count) / $(cat /proc/sys/net/netfilter/nf_conntrack_max) * 100" | bc

# If close to 100%, this is likely the problem!

# Statistics
cat /proc/net/stat/nf_conntrack
# Look for 'drop' or 'early_drop' increasing

# View table
conntrack -L | head -20

# Count by state
conntrack -L | awk '{print $4}' | sort | uniq -c | sort -rn

# Temporary fix:
sudo sysctl -w net.netfilter.nf_conntrack_max=262144

# Permanent in /etc/sysctl.conf:
net.netfilter.nf_conntrack_max = 262144
```

**Step 4: Check Firewall**

```bash
# Check for REJECT/DROP rules
sudo iptables -L -n -v | grep -E "REJECT|DROP"

# Specific chains
sudo iptables -L INPUT -n -v
sudo iptables -L FORWARD -n -v

# Count dropped packets
sudo iptables -L -n -v -Z  # Zero counters
# Wait, then check again
sudo iptables -L -n -v

# Rate limiting
sudo iptables -L -n -v | grep limit
```

**Step 5: Check with ss**

```bash
# Retransmissions
ss -ti | grep bytes_retrans | grep -v "bytes_retrans:0"

# Connection states
ss -tan state established | wc -l
ss -tan state time-wait | wc -l
ss -tan state close-wait | wc -l   # Many = app not closing sockets

# Summary statistics
ss -s
# Look for:
# - TCPBacklogDrop
# - ListenDrops
# - TCPTimeouts
```

**Step 6: Check Kernel Limits**

```bash
# File descriptors
ulimit -n
cat /proc/sys/fs/file-nr

# Socket buffers
sysctl net.ipv4.tcp_rmem
sysctl net.ipv4.tcp_wmem

# TCP backlog
sysctl net.ipv4.tcp_max_syn_backlog
sysctl net.core.somaxconn

# Statistics
netstat -s | grep -i drop
netstat -s | grep -i listen
```

---

#### Distinguishing Between Causes

**Application Issue:**

- RST in middle of established connection
- Application logs show errors
- Happens under load or after timeout
- Many CLOSE-WAIT states

**Firewall Issue:**

- RST immediately after SYN or early
- iptables counters show REJECT/DROP increasing
- Consistent from certain IPs
- RST from server IP (not app process)

**Connection Tracking Full:**

- nf_conntrack_count ≈ nf_conntrack_max
- Intermittent during high traffic
- dmesg shows "table full" messages
- Sudden RST on established connections

**Kernel Limits:**

- netstat -s shows backlog/listen drops
- File descriptor limits reached
- Happens under high connection rate

---

### Quick Diagnostic Script

```bash
#!/bin/bash
echo "=== Connection Tracking ==="
echo "Count: $(cat /proc/sys/net/netfilter/nf_conntrack_count)"
echo "Max: $(cat /proc/sys/net/netfilter/nf_conntrack_max)"
echo "Usage: $(echo "scale=2; $(cat /proc/sys/net/netfilter/nf_conntrack_count) / $(cat /proc/sys/net/netfilter/nf_conntrack_max) * 100" | bc)%"

echo -e "\n=== TCP Socket States ==="
ss -tan | awk '{print $1}' | sort | uniq -c

echo -e "\n=== Netstat Drops ==="
netstat -s | grep -i "drop\|overflow"

echo -e "\n=== Recent Kernel Messages ==="
dmesg | tail -20

echo -e "\n=== Firewall Drops ==="
iptables -L -n -v | grep -E "DROP|REJECT" | head -10
```

---

## Essential Commands Reference

### Process Investigation

```bash
ps aux --sort=-%cpu              # CPU hogs
ps aux --sort=-%mem              # Memory hogs
ps -eLf                          # All threads
ps -o ppid= -p PID               # Get parent PID
pgrep -a process_name            # Find by name
pidof process_name               # Get PID
/proc/PID/status                 # Detailed info
/proc/PID/cmdline                # Command line
/proc/PID/fd/                    # Open file descriptors
lsof -p PID                      # Open files
strace -c -p PID                 # System call summary
pstack PID                       # Stack trace
```

### Signals

```bash
kill -l                          # List all signals
kill -TERM PID                   # Graceful (15)
kill -KILL PID                   # Force (9)
kill -STOP PID                   # Pause (19)
kill -CONT PID                   # Resume (18)
kill -HUP PID                    # Reload config (1)
killall process_name             # Kill by name
pkill -f "pattern"               # Kill by pattern
kill -TERM -PGID                 # Kill process group
```

### File System

```bash
df -h                            # Disk space
df -i                            # Inode usage
du -sh /*                        # Directory sizes
lsof +L1                         # Deleted but open
lsof | grep deleted              # Alternative
stat filename                    # File metadata
ls -i                            # Show inode numbers
find / -inum INODE               # Find by inode
tune2fs -l /dev/sda1             # Filesystem info
```

### Network - Basic

```bash
ss -tulnp                        # All listening
ss -tanp                         # All connections
ss -s                            # Summary stats
ss -ti                           # TCP details
ss 'sport = :80'                 # Filter by port
ss state established             # By state
ping -c 4 host                   # Connectivity
traceroute host                  # Path
mtr host                         # Combined ping/trace
```

### Network - Advanced

```bash
ip addr show                     # Interfaces
ip -s link                       # Interface stats
ip route show                    # Routing table
netstat -s                       # Protocol stats
tcpdump -i any host X            # Packet capture
tcpdump -nn port 443             # Specific port
lsof -i :PORT                    # What's using port
nc -zv host port                 # Test connection
dig domain                       # DNS lookup
conntrack -L                     # Connection tracking table
```

### Performance Monitoring

```bash
top / htop                       # Real-time overview
vmstat 1                         # Virtual memory
iostat -x 1                      # Disk I/O
mpstat -P ALL 1                  # Per-CPU stats
sar -u 1 10                      # Historical CPU
iotop                            # I/O by process
iftop                            # Network by connection
dstat                            # Combined view
```

### System Information

```bash
uname -a                         # Kernel version
cat /etc/os-release              # OS version
lscpu                            # CPU info
free -h                          # Memory
uptime                           # Load average
dmesg | tail                     # Kernel messages
journalctl -xe                   # System logs
systemctl status service         # Service status
```

---

## Common Interview Traps

### ❌ Avoid These Mistakes

**Trap 1: "I'd restart the server"**

- ✅ Better: Show systematic troubleshooting first

**Trap 2: Wrong signals**

- ❌ "SIGINT pauses processes"
- ✅ SIGSTOP/SIGTSTP pause; SIGINT terminates

**Trap 3: Vague answers**

- ❌ "I'd check the logs"
- ✅ "I'd check application logs with `journalctl -u service -f` and kernel messages with `dmesg`"

**Trap 4: Forgetting permissions**

- Many commands need sudo: ss -p, lsof, strace, tcpdump
- Mention this in answers

**Trap 5: Tool confusion**

- ❌ "netstat is better than ss"
- ✅ ss is faster and more powerful

---

## Communication Tips

### Structure Your Answers

1. **Acknowledge:** "That's a good question about..."
2. **State approach:** "I'd begin by checking..."
3. **Show systematic thinking:** "First... then... finally..."
4. **Mention trade-offs:** "This approach is fast but less detailed"
5. **Admit uncertainty:** "I'm not certain, but I believe..." is better than guessing

### Think Out Loud

- "I'm considering whether this is a network or application issue..."
- "Let me work through the TCP state machine..."
- "That's interesting, I haven't seen this exact scenario, but I'd approach it by..."

### Ask Clarifying Questions

- "Is this a production system where I need to avoid service disruption?"
- "Do I have root access?"
- "Are there any monitoring tools already in place?"
- "What's the typical load on this system?"

---

## Key Concepts Summary

### Inodes

- Store metadata (permissions, timestamps, size, pointers to data)
- Do NOT store filename or file content
- Filename → Directory Entry → Inode → Data Blocks
- Running out of inodes = can't create files despite free space
- Check with: `df -i`
- View with: `ls -i`

### File Deletion

- `rm` calls `unlink()` system call
- Removes directory entry, decrements inode link count
- Data deleted when link count = 0 AND no processes have file open
- Data not immediately overwritten (file recovery possible)

### Hard Links vs Symlinks

- **Hard:** Same inode, survives target deletion, same filesystem only
- **Symlink:** Own inode with path string, breaks if target deleted, cross-filesystem OK

### Process States

- **R:** Running/runnable
- **S:** Sleeping (interruptible)
- **D:** Sleeping (uninterruptible) - CANNOT BE KILLED
- **Z:** Zombie (already dead, waiting for parent to reap)
- **T:** Stopped (SIGSTOP/SIGTSTP)

### Signals

- **SIGTERM (15):** Graceful shutdown (catchable, default)
- **SIGKILL (9):** Force kill (uncatchable)
- **SIGSTOP (19):** Pause (uncatchable)
- **SIGCONT (18):** Resume
- **SIGHUP (1):** Hangup/reload config
- **SIGINT (2):** Interrupt (Ctrl+C)
- **SIGTSTP (20):** Stop (Ctrl+Z, catchable)

### TCP States

- **LISTEN:** Waiting for connections
- **SYN-SENT/SYN-RECEIVED:** Handshake in progress
- **ESTABLISHED:** Active connection
- **TIME-WAIT:** Connection closed, waiting 2MSL for stray packets
- **CLOSE-WAIT:** Remote closed, local hasn't closed yet (app issue if many)

### TCP vs UDP

- **TCP:** Reliable, connection-oriented, retransmits lost packets, higher overhead
- **UDP:** Unreliable, connectionless, no retransmission, lower latency, less overhead
- **TCP use:** HTTP, SSH, file transfer (need reliability)
- **UDP use:** DNS, VoIP, streaming, gaming (need speed)

### netstat vs ss

- **ss:** Faster (netlink), more powerful filtering, detailed TCP info, modern
- **netstat:** Slower (/proc), basic info, legacy, deprecated

### Disk Space Issues

1. **Deleted files open:** `lsof +L1`
2. **Inode exhaustion:** `df -i`
3. **Reserved blocks:** `tune2fs -l`
4. **Hidden mounts:** `umount` and check

### Connection Reset

- **Application:** RST mid-connection, logs show errors, many CLOSE-WAIT
- **Firewall:** RST after SYN, iptables counters increasing
- **Connection tracking:** nf_conntrack_count near max, dmesg warnings
- **Kernel limits:** netstat -s shows drops, file descriptor exhaustion

---

## Practice Scenarios

### Scenario 1: Mysterious Disk Usage

```
Problem: Server reports 95% disk usage, but du -sh / shows only 60% used

Your approach:
1. Check for deleted files still open: lsof +L1
2. Check inode usage: df -i
3. Compare df vs du output
4. Check for hidden mounts
5. Look for large logs being rotated but held open

Expected answer: Identify root cause and explain recovery steps
```

### Scenario 2: Unkillable Process

```
Problem: Process consuming 100% CPU, won't respond to kill -9

Your approach:
1. Check process state: ps aux | grep PID
2. If state is D: investigate I/O (iostat, lsof -p PID, /proc/PID/stack)
3. If state is not D: verify you're killing correct PID, check if zombie
4. Explain why D state can't be killed
5. Propose solutions based on root cause

Expected answer: Systematic diagnosis, understand kernel vs userspace
```

### Scenario 3: Intermittent Connection Failures

```
Problem: Web app occasionally returns "Connection reset by peer"

Your approach:
1. Capture RST packets: tcpdump
2. Check connection tracking: nf_conntrack_count vs max
3. Check application logs
4. Use ss to check TCP health: bytes_retrans, socket states
5. Check firewall rules: iptables -L -n -v
6. Check kernel limits: netstat -s, ulimit

Expected answer: Distinguish between app, firewall, and kernel causes
```

### Scenario 4: Slow File Transfer

```
Problem: scp transfer between servers is very slow despite high bandwidth

Your approach:
1. Check network basics: ping, traceroute
2. Check interface stats: ip -s link, ethtool
3. Check TCP performance: ss -ti for RTT, cwnd, retransmissions
4. Test throughput: iperf3
5. Check for packet loss: netstat -s | grep retrans
6. Consider TCP tuning, MTU issues, SSH cipher overhead

Expected answer: Layer-by-layer network troubleshooting
```

---

## MongoDB-Specific Context

### What MongoDB Values

Based on their engineering principles:

**1. Resilience**

- Think about failure modes
- How would you monitor this?
- What happens when it breaks?
- "Design for failure" mentality

**2. Operational Excellence**

- Automation over manual intervention
- Observability and debugging
- Learning from incidents

**3. Systematic Thinking**

- Structured troubleshooting approach
- Root cause analysis
- Reproducible investigations

### During Interview

**Show operational thinking:**

- "I'd want to set up monitoring for this metric..."
- "To prevent this in future, I'd implement..."
- "This would let me debug issues without impacting users..."

**Consider distributed systems:**

- "In a distributed environment, I'd also check..."
- "Network partitions could cause..."
- "Eventual consistency means..."

**Focus on reliability:**

- "The safest approach would be..."
- "To avoid downtime, I'd first..."
- "This has lower risk because..."

---

## Day-Before Checklist

### Mental Preparation

**Remember:**

- Partial answers with reasoning > wrong confident answers
- It's OK to say "I'm not sure, but here's how I'd investigate..."
- Think out loud - interviewers want to see your process
- Ask clarifying questions - shows thoroughness
- Communication matters as much as technical knowledge

**Get Good Sleep:**

- This interview rewards clear thinking over memorization
- Being well-rested helps with systematic reasoning
- Don't cram the night before

---

## Quick Reference - Most Important Commands

### The "Top 20" You Must Know

```bash
# Process management
ps aux --sort=-%cpu
top / htop
kill -TERM PID
kill -STOP PID
/proc/PID/status

# File system
df -h / df -i
du -sh /*
lsof +L1
ls -i
stat filename

# Networking
ss -tulnp
ss -ti
ping / traceroute
tcpdump -i any port 80
ip addr show

# Troubleshooting
dmesg | tail
journalctl -xe
strace -c -p PID
iostat -x 1
vmstat 1
```

### Quick Answers to Common Questions

**"Why can't I create files despite free space?"**
→ Check `df -i` for inode exhaustion

**"Why can't I kill this process?"**
→ Check state with `ps aux | grep PID`. If D state, it's in uninterruptible I/O

**"What's using all my disk space?"**
→ Check `lsof +L1` for deleted but open files

**"Connections keep resetting"**
→ Check connection tracking: `cat /proc/sys/net/netfilter/nf_conntrack_count`

**"How do I see what a process is doing?"**
→ `strace -c -p PID` for syscalls, `lsof -p PID` for files, `/proc/PID/status` for state

**"Process won't respond to SIGTERM"**
→ Escalate to `kill -KILL PID`, unless D state (then fix I/O issue)

**"Network is slow"**
→ Check with `ss -ti` for retransmissions and RTT, `iostat` for I/O wait

**"Too many connections in TIME-WAIT"**
→ Normal for busy servers (2MSL timeout), tune `tcp_tw_reuse` if needed

---

## Final Tips

### What Interviewers Look For

**1. Structured Thinking**

- Not jumping to conclusions
- Systematic elimination of causes
- Layer-by-layer approach

**2. Practical Knowledge**

- Real commands, not just theory
- Understanding when to use which tool
- Edge cases and failure modes

**3. Communication**

- Explaining thought process
- Acknowledging uncertainty
- Asking good questions

**4. Operational Mindset**

- Impact on production
- Monitoring and prevention
- Automation opportunities

### Red Flags to Avoid

- ❌ Guessing without admitting uncertainty
- ❌ Memorized answers without understanding
- ❌ Ignoring edge cases
- ❌ Forgetting to mention need for sudo/root
- ❌ Vague answers ("check the logs" without specifics)
- ❌ Immediate restart without investigation

### Green Flags to Show

- ✅ Structured troubleshooting approach
- ✅ Multiple solution approaches
- ✅ Awareness of trade-offs
- ✅ Thinking about prevention
- ✅ Clear communication
- ✅ Honest about gaps in knowledge

---

## Good Luck!

Remember: This interview is about **how you think**, not just what you know.

- Stay calm and systematic
- Think out loud
- Ask clarifying questions
- Acknowledge when you're uncertain
- Show your reasoning process

You've got this! 🚀
