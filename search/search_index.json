{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Site Reliability Engineering","text":"<p>Quote</p> <p>\"Hope is not a strategy.\"</p>"},{"location":"#project-overview","title":"Project Overview","text":"<p>This project aims to collate a comprehensive body of knowledge for Site Reliability Engineering (SRE), bringing together best practices, methodologies, and essential concepts that define the discipline. SRE bridges the gap between development and operations, focusing on the reliability and scalability of large-scale systems.</p>"},{"location":"behavioral/","title":"STAR Method","text":"<p>The STAR interview method is a technique you can use to prepare for behavioral and situational interview questions. STAR stands for situation, task, action and result. Hiring managers ask behavioral interview questions to determine whether you are the right fit for a job. This method will help you prepare clear and concise responses using real-life examples.</p> <p>When and where it took place.</p> <p></p> <p>What was your role?</p> <p></p> <p>What were your specific contributions?</p> <p></p> <p>What did you produce?</p> <p></p>"},{"location":"behavioral/#situation","title":"Situation","text":""},{"location":"behavioral/#task","title":"Task","text":""},{"location":"behavioral/#actions","title":"Actions","text":""},{"location":"behavioral/#results","title":"Results","text":""},{"location":"behavioral/#behavioral-preparation","title":"Behavioral Preparation","text":"Why are you interested in this role?   - What is the interviewer looking for: The interviewer is trying to understand what drives you, how your values align with the company\u2019s, what are the chances to accept the offer if offered, and what is the chance you will do well in this company.  - Best practice to answer: Choose an answer where your goals align with the position and also show the value-add to the company. It should be tailored according to the specific job position. Show how your actions and your plans are in harmony. Your knowledge, enthusiasm, and efforts will go a long way in answering this question. A good way to answer this question is to illustrate how well this job aligns with your career goals.  In your answer, you should focus on your primary reasons: impact, learning, career growth.  Question variations:  - Why do you want to work here?  - How is this role in alignment with your career goals? - What do you want to get in your next job?  What drags you out of bed?  What is the interviewer looking for: The interviewer is looking for the motivational factors that keep you going. The interviewer will try to aggregate your answers, your strengths, and your background to form an overall view of you and assess how well you will fit in the team\u2019s needs.  Best practice to answer: Talk about what you care most deeply, why it matters to you, and how you have committed 100% of your energy to do things you care, no matter if it is technology advancement, business success, amazing user experience, or learning new things to expedite your growth.  It is ok to joke it is the kids and the alarm that get you up, but please do not stop there. The interviewers want to know more about what drives you.  Question variations:  - What keeps you going?  - If you have achieved financial freedom today, what will you be doing? - What is your dream job?  Do you have any questions for me?  What is the interviewer looking for: On one side, the interviewer is giving you an opportunity to ask questions so that you have a better understanding of the company. On the other hand, the interviewer is also going to form her opinion about how excited you are with the company, based on the questions you have asked.  Best practice to answer: You should think about two things here. One is to ask questions that you still have about the company and the role. Just as the company is interviewing you, you are interviewing it as well. The other is to ask questions that demonstrate your passion, knowledge and thought leadership in this space.  If you do not have questions or your questions are very superficial, it will be a clear indicator that you are not highly interested in the role, or you are not a curious person. Both cases are bad signs to an interviewer.  Below are some sample questions that can help you get started:  - What big trends do you see in xxx space in the next 3 years? - What 3-5 words will you use to describe the team\u2019s culture? - What are the biggest challenges that someone in this role will face? - What does your day look like? - How satisfied is the team with their career development? Conflict Resolution with a Colleague  What is the interviewer looking for: he interviewer is looking for the conflict resolution skills and your resilience. The following are a few areas that the interviewer is going to assess you.  - Did you listen well? - Did you try to fully understand the other party\u2019s story? - Did you work with other parties to come up with a creative solution to resolve the conflict, etc? - Did you try to resolve the conflict before escalation? Best practice to answer:  Use the STAR framework. Describe the situation and the task. The actions you took to resolve the situation and the result. Ideally, showcase some good moves that you undertook to resolve the conflict. Some sample moves are:  - Proactively reach out to the other party to fully understand their perspective.  - Assume good intent. Do not be judgmental about the other party\u2019s move. Most conflicts in a workplace is caused by misinterpreting the - other party\u2019s intent. - Steer both parties to find solutions that are optimized for the company and the combined team. - If needed, escalate to the right authorities in a timely manner.  - After the conflict was resolved, reach out to further strengthen the relationship with the other party.  Question variations:  - How did you resolve conflicts in your team?  - Tell me about a time when you had an issue with a coworker  - How do you handle disagreement with your teammates?  - Tell me about a situation when you had to work in a group that wasn\u2019t functioning well. What happened?  Disagree with Leadership  What is the interviewer looking for: The interviewer is looking for your involvement in the decision-making and post-decision process. In particular, how well did you function as a leader to make your voice heard before the decision? And how well did you demonstrate followership to support a decision that you disagree?  Best practice to answer: It is a good practice to share your philosophy about decisions. A good practice is to be actively involved in the decision discussion so that your voice is heard and assist the decision maker to make the right decision with all the relevant data and different perspectives available before the decision making. Once a decision is made, follow and support the decision even if you do not agree. To illustrate active participation during decision process, you should share your perspective and why you prefer this route, how does it compare with the ultimate decision. You should also share how the final decision played out. If it played out well, please share what you have learned from this. If it did not work out, did the team come back to retry with your approach? If it did, what could you have done differently to better influence the team before the decision was made?  Question variations:  - What do you do if you disagree with your manager? - Share one experience that you argued forcefully but turned out you were wrong. Experience of Compromising  What is the interviewer looking for: We have all experienced situations where people share different opinions and are stuck in stalemate since nobody can convince anyone. In such situations, it is often the case that proceeding with any option is better than being stuck. Strong leaders seek to make compromises in such cases so that the team can proceed. It is a critical skill to make the right compromises in any type of organizations. When asking this question, the interviewers are trying to assess your flexibility and your creativity to make the right compromises to resolve conflicts.  Best practice to answer:  Without saying, you need to use the STAR method to describe the situation, what you did and the result. Simply making a compromise is never a strong leadership. You need to showcase why making a compromise was the right thing to do in this circumstance, what you did to break the stalemate and how you subsequently resolved the conflict. Make sure you lay the foundation, why different people have different views and how everyone believes theirs is correct. Explain what you did to make sure everyone understood the situation, the compromises that the team had to make and articulate the actions that made a difference.  Question variations:  - Share one experience where you stepped back and found a better solution.  - Share an experience that solved a problem by collaborating with others.  Leadership  What is the interviewer looking for: Obviously, the expectation of leadership varies drastically based on your experience level. For a junior member, the interviewers will likely look for :  - Demonstrate and drive accountability, - Take initiatives, and - Foster collaboration among team members.    For a more senior candidate, the interviewers will likely look for:  - Establish vision, - Get buy-in across the organization, - Orchestrate the execution of a large-scale initiative, and - Drive changes  Best practice to answer:  It is impossible for you to cover every dimension of leadership. Please select a story that can primarily highlight one aspect of leadership that you want the interviewer to take away. Your primary goal is for the interviewer to remember the initiatives you had undertaken, the magnitude of the accomplishment, and the most significant leadership dimension you had demonstrated. To make sure your message genuinely stands out, you can provide a brief at the end of the story.  You may want to tell different stories depending who is asking the question since a hiring manager or a teammate may appreciate different things. It is perfectly fine for you to use the same story, but may want to emphasize different elements based on what you know about the interviewer.  Please make sure to be specific about the details of the project and what you did for it to be successful. There are many factors that contribute to the success of an initiative. You want to make the interviewer believe your leadership has played a critical role in the success.  Question variations:  - Tell me a successful project that you were part of  - Tell me an experience that you have driven a change successfully  Leadership Style  What is the interviewer looking for: We all want to work with strong individuals, and most of us do not want to work with jerks no matter how strong this individual is. When an interviewer asks for this question, she is trying to understand:  - What is your leadership style? - Will you be a good fit for the company? - Are you easy to work with? - Does she want you to be her teammate?   Best practice to answer:  Be genuine. Share the true leadership traits that you have heard others describe you. Do not try to be someone you are not. Use some light-weight examples to support your statement, but do not go into too much detail. The interviewer is asking for others perception about you. Too many details imply, you are trying too hard. For example, if you say you bring positive energy and fun to the team, you can give examples on how many team events you organize, either ad-hoc or planned, but no need to go into specific detail for the events since they are not important for the question. Again, 3 is the magic number. Please pick up three things to describe your own leadership style. At the end, do a brief summary so that the interviewer has the best chance to capture and appreciate it.  Question variations:  - What\u2019s your leadership style?  - Which leadership trait do you wish to have but you do not possess today?  <ol> <li> <p>Give me an example of a time you had a conflict with a team member. How did you handle it? </p> </li> <li> <p>Tell me about a time you made a mistake that affected a customer. How did you resolve the problem? </p> </li> <li> <p>Describe an occasion when you had to manage your time to complete a task. How did you do it? </p> </li> <li> <p>Describe an occasion when you failed at something. What did you learn? </p> </li> <li> <p>Tell me about a time you went beyond the call of duty. Why did you do this, and what happened? </p> </li> <li> <p>Describe a time when you had to do something you weren't trained to do. How did you handle it? </p> </li> </ol> <p></p>"},{"location":"behavioral/#motivation-and-values","title":"Motivation and Values","text":""},{"location":"behavioral/#conflict-resolution","title":"Conflict Resolution","text":""},{"location":"behavioral/#leadership","title":"Leadership","text":""},{"location":"behavioral/#sample-behavioral-interview-questions","title":"Sample behavioral interview questions","text":""},{"location":"databases/","title":"Databases","text":"<p>Consistency   All the servers in the system will have the same data so users will get the same copy regardless of which server answers their request.</p> <p>Availability   The system will always respond to a request (even if it's not the latest data or consistent across the system or just a message saying the system isn't working).</p> <p>Partition Tolerance   The system continues to operate as a whole even if individual servers fail or can't be reached.</p> <p></p> <p>Atomicity   An indivisible and irreducible series of database operations such that either all occurs, or nothing occurs.</p> <p>Consistency   Understood as after a successful write, update or delete of a Record, any read request immediately receives the latest value of the Record.</p> <p>Isolation  Any reads or writes performed on the database will not be impacted by other reads and writes of separate transactions occurring on the same database. A global order is created with each transaction queueing up in line to ensure that the transactions complete in their entirety before another one begins.</p> <p>Durability  Durability ensures that changes made to the database (transactions) that are successfully committed will survive permanently, even in the case of system failures (e.g.; change logs).</p> <p></p> <p>Normalization entails organizing the columns and tables of a database to ensure that their dependencies are properly enforced by database integrity constraints.</p> <p>1NF  In simple terms, a single cell cannot hold multiple values. If a table contains a composite or multi-valued attribute, it violates the First Normal Form.  </p> <p>2NF  The first condition in the 2nd NF is that the table has to be in 1st NF. The table also should not contain partial dependency.</p> <p>3NF  The same rule applies as before i.e, the table has to be in 2NF before proceeding to 3NF. The other condition is there should be no transitive dependency for non-prime attributes. That means non-prime attributes (which doesn\u2019t form a candidate key) should not be dependent on other non-prime attributes in a given table.</p> <p>Boyce Codd Normal Form (BCNF)  In BCNF if every functional dependency A \u2192 B, then A has to be the Super Key of that particular table.</p> <p></p> <p> </p> Schema Fixed Schema I.e. Tables and Columns are preferred Storage Table (Row -&gt; Entity, Column -&gt; Attributes) RDBMS Oracle, IBM DB2, MSSQL, MySQL Query SQL Scalability In common situation suitable for Vertical scaling ACID Compliance Compliant <p></p> <p> </p> Schema Dynamic schema I.e. Can store data for entity and its attributes dynamically Storage Key Value, Document, Graph, Wide-column Query unSQL Scalability In common situation suitable for Horizontal scaling ACID Compliance Compromises ACID properties <p></p> <p>Transaction workloads require a normalized design while analytical workloads require a denormalized design. </p> <p>A 3NF assures data consistency and accuracy but performance may be reduced due to the multiple joins involved. </p> <p> </p>"},{"location":"databases/#cap-theorem","title":"CAP Theorem","text":"<p> Distributed data stores that claims, in the event of a network failure on a distributed database, it is possible to provide either consistency or availability\u2014but not both.  </p>"},{"location":"databases/#acid","title":"ACID","text":""},{"location":"databases/#normalization","title":"Normalization","text":""},{"location":"databases/#relational-databases-sql","title":"Relational Databases (SQL)","text":"<p> Known for storing data in spreadsheet-like tables that have their columns and data types strictly defined. The tables can have relationships between each other and the data is queried with SQL (Structured Query Language)</p>"},{"location":"databases/#nosql","title":"NoSQL","text":"<p> NoSQL databases (aka \"not only SQL\") are non-tabular databases and store data differently than relational tables. NoSQL databases come in a variety of types based on their data model. The main types are document, key-value, wide-column, and graph. They provide flexible schemas and scale easily with large amounts of data and high user loads.</p>"},{"location":"databases/#scaling-considerations","title":"Scaling Considerations","text":""},{"location":"linux/commands-reference/","title":"Linux Commands Reference Guide","text":"<p>This guide provides essential Linux commands for system administration, monitoring, and troubleshooting with practical examples and output explanations.</p>"},{"location":"linux/commands-reference/#process-and-system-information","title":"Process and System Information","text":""},{"location":"linux/commands-reference/#process-information-commands","title":"Process Information Commands","text":""},{"location":"linux/commands-reference/#ps-aux","title":"<code>ps aux</code>","text":"<p>Shows all running processes with detailed information.</p> <pre><code>ps aux\n</code></pre> <p>Output columns:</p> <ul> <li>USER: Process owner</li> <li>PID: Process ID</li> <li>%CPU: CPU usage percentage</li> <li>%MEM: Memory usage percentage</li> <li>VSZ: Virtual memory size (KB)</li> <li>RSS: Resident memory size (KB)</li> <li>TTY: Terminal type</li> <li>STAT: Process state</li> <li>START: Start time</li> <li>TIME: CPU time used</li> <li>COMMAND: Command that started the process</li> </ul>"},{"location":"linux/commands-reference/#pstree","title":"<code>pstree</code>","text":"<p>Displays processes in a tree format showing parent-child relationships.</p> <pre><code>pstree\n</code></pre> <p>Shows hierarchical process relationships, useful for understanding process spawning.</p>"},{"location":"linux/commands-reference/#top","title":"<code>top</code>","text":"<p>Real-time display of running processes and system resource usage.</p> <pre><code>top\n</code></pre> <p>Key metrics displayed:</p> <ul> <li>Load average (1, 5, 15 minutes)</li> <li>CPU usage breakdown</li> <li>Memory usage (total, used, free, buffers)</li> <li>Process list sorted by CPU usage</li> </ul>"},{"location":"linux/commands-reference/#htop","title":"<code>htop</code>","text":"<p>Enhanced interactive version of top with color coding and mouse support.</p> <pre><code>htop\n</code></pre> <p>More user-friendly interface with color-coded information and additional features.</p>"},{"location":"linux/commands-reference/#process-identification-and-management","title":"Process Identification and Management","text":""},{"location":"linux/commands-reference/#finding-processes","title":"Finding Processes","text":"<p>Find processes by name:</p> <pre><code>ps aux | grep processname\npgrep processname          # Returns PID only\npgrep -f processname       # Match full command line\n</code></pre> <p>Find processes by user:</p> <pre><code>ps aux | grep username\nps -u username\n</code></pre> <p>Find processes using a port:</p> <pre><code>netstat -tuln | grep :8080\nss -tuln | grep :8080\nlsof -i :8080\n</code></pre> <p>Find processes by PID:</p> <pre><code>ps -p 1234\nps aux | grep 1234\n</code></pre>"},{"location":"linux/commands-reference/#process-state-codes-stat-column-in-ps-aux","title":"Process State Codes (STAT column in ps aux)","text":"<ul> <li>R: Running or runnable</li> <li>S: Interruptible sleep (waiting for event)</li> <li>D: Uninterruptible sleep (usually I/O)</li> <li>Z: Zombie process</li> <li>T: Stopped (by job control signal)</li> <li>t: Stopped by debugger</li> <li>W: Paging (not valid since kernel 2.6)</li> <li>X: Dead (should never be seen)</li> </ul> <p>Additional modifiers:</p> <ul> <li>&lt;: High priority (not nice to other users)</li> <li>N: Low priority (nice to other users)</li> <li>L: Has pages locked into memory</li> <li>s: Session leader</li> <li>l: Multi-threaded</li> <li>+: In foreground process group</li> </ul>"},{"location":"linux/commands-reference/#killing-processes","title":"Killing Processes","text":"<p>Kill by PID:</p> <pre><code>kill 1234              # Send SIGTERM (graceful shutdown)\nkill -9 1234          # Send SIGKILL (force kill)\nkill -15 1234         # Send SIGTERM explicitly\n</code></pre> <p>Kill by process name:</p> <pre><code>pkill processname      # Kill all processes matching name\nkillall processname   # Kill all processes by name\npkill -f pattern      # Kill processes matching pattern in command line\n</code></pre> <p>Kill processes by user:</p> <pre><code>pkill -u username     # Kill all processes owned by user\nkillall -u username   # Alternative syntax\n</code></pre> <p>Signal types:</p> <ul> <li>SIGTERM (15): Graceful termination request</li> <li>SIGKILL (9): Immediate termination (cannot be caught/ignored)</li> <li>SIGHUP (1): Hangup signal (often reloads config)</li> <li>SIGSTOP (19): Stop process (cannot be caught/ignored)</li> <li>SIGCONT (18): Continue stopped process</li> </ul>"},{"location":"linux/commands-reference/#advanced-process-commands","title":"Advanced Process Commands","text":"<p>Process tree with PIDs:</p> <pre><code>pstree -p              # Show PIDs in tree\npstree -p username     # Show tree for specific user\n</code></pre> <p>Detailed process information:</p> <pre><code>ps -ef                 # Full format listing\nps -eo pid,ppid,cmd,%mem,%cpu --sort=-%cpu    # Custom format sorted by CPU\n</code></pre> <p>Process resource usage:</p> <pre><code>pidstat               # Per-process statistics\npidstat -p 1234       # Statistics for specific PID\niotop                 # Real-time I/O usage by process\n</code></pre> <p>Background process management:</p> <pre><code>nohup command &amp;       # Run command immune to hangups\njobs                  # List active jobs\nbg %1                 # Send job to background\nfg %1                 # Bring job to foreground\ndisown %1             # Remove job from shell's job table\n</code></pre>"},{"location":"linux/commands-reference/#system-information-commands","title":"System Information Commands","text":""},{"location":"linux/commands-reference/#uname-a","title":"<code>uname -a</code>","text":"<p>Display system information.</p> <pre><code>uname -a\n</code></pre> <p>Example output:</p> <pre><code>Linux ubuntu-pod 5.4.0-74-generic #83-Ubuntu SMP Sat May 8 02:35:39 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux\n</code></pre> <p>Shows: kernel name, hostname, kernel version, build info, architecture.</p>"},{"location":"linux/commands-reference/#procversion","title":"<code>/proc/version</code>","text":"<p>Kernel version and build information.</p> <pre><code>cat /proc/version\n</code></pre> <p>Example output:</p> <pre><code>Linux version 5.4.0-74-generic (buildd@lcy01-amd64-030) (gcc version 9.4.0)\n</code></pre>"},{"location":"linux/commands-reference/#proccpuinfo","title":"<code>/proc/cpuinfo</code>","text":"<p>Detailed CPU information.</p> <pre><code>cat /proc/cpuinfo\n</code></pre> <p>Key information:</p> <ul> <li>processor: CPU core number</li> <li>model name: CPU model</li> <li>cpu MHz: Current frequency</li> <li>cache size: CPU cache information</li> <li>flags: Supported CPU features</li> </ul>"},{"location":"linux/commands-reference/#procmeminfo","title":"<code>/proc/meminfo</code>","text":"<p>Detailed memory information.</p> <pre><code>cat /proc/meminfo\n</code></pre> <p>Key fields:</p> <ul> <li>MemTotal: Total physical memory</li> <li>MemFree: Free memory</li> <li>MemAvailable: Available memory for applications</li> <li>Buffers: Memory used for buffers</li> <li>Cached: Memory used for caching</li> </ul>"},{"location":"linux/commands-reference/#free-h","title":"<code>free -h</code>","text":"<p>Memory usage in human-readable format.</p> <pre><code>free -h\n</code></pre> <p>Example output:</p> <pre><code>              total        used        free      shared  buff/cache   available\nMem:           7.8G        2.1G        3.2G        156M        2.5G        5.3G\nSwap:          2.0G          0B        2.0G\n</code></pre>"},{"location":"linux/commands-reference/#file-system-commands","title":"File System Commands","text":""},{"location":"linux/commands-reference/#df-h","title":"<code>df -h</code>","text":"<p>Display filesystem disk space usage in human-readable format.</p> <pre><code>df -h\n</code></pre> <p>Example output:</p> <pre><code>Filesystem      Size  Used Avail Use% Mounted on\n/dev/sda1        20G  8.5G   10G  46% /\ntmpfs           3.9G     0  3.9G   0% /dev/shm\n</code></pre>"},{"location":"linux/commands-reference/#mount","title":"<code>mount</code>","text":"<p>Display mounted filesystems.</p> <pre><code>mount\n</code></pre> <p>Shows all currently mounted filesystems with mount options.</p>"},{"location":"linux/commands-reference/#procmounts","title":"<code>/proc/mounts</code>","text":"<p>Kernel's view of mounted filesystems.</p> <pre><code>cat /proc/mounts\n</code></pre> <p>More detailed than <code>mount</code> command, shows kernel perspective.</p>"},{"location":"linux/commands-reference/#lsblk","title":"<code>lsblk</code>","text":"<p>List block devices in tree format.</p> <pre><code>lsblk\n</code></pre> <p>Example output:</p> <pre><code>NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsda      8:0    0   20G  0 disk\n\u2514\u2500sda1   8:1    0   20G  0 part /\n</code></pre>"},{"location":"linux/commands-reference/#memory-and-virtual-memory","title":"Memory and Virtual Memory","text":""},{"location":"linux/commands-reference/#memory-statistics","title":"Memory Statistics","text":""},{"location":"linux/commands-reference/#procvmstat","title":"<code>/proc/vmstat</code>","text":"<p>Virtual memory statistics.</p> <pre><code>cat /proc/vmstat\n</code></pre> <p>Key metrics:</p> <ul> <li>nr_free_pages: Free memory pages</li> <li>nr_dirty: Dirty pages waiting to be written</li> <li>pgpgin/pgpgout: Pages paged in/out</li> <li>pswpin/pswpout: Pages swapped in/out</li> </ul>"},{"location":"linux/commands-reference/#vmstat-1-5","title":"<code>vmstat 1 5</code>","text":"<p>Display virtual memory statistics every 1 second for 5 iterations.</p> <pre><code>vmstat 1 5\n</code></pre> <p>Example output:</p> <pre><code>procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0      0 3298516 268844 2598808    0    0     8    12   42   78  2  1 97  0  0\n</code></pre> <p>Key columns explained:</p> <p>System columns: - <code>in</code>: Interrupts per second (42/sec) - includes clock and device interrupts - <code>cs</code>: Context switches per second (78/sec) - process/thread switching</p> <p>Relationship between <code>in</code> and <code>cs</code>: - Context switches typically exceed interrupts (78 &gt; 42 in this example) - One interrupt can trigger multiple context switches - Context switches also occur due to scheduling, I/O waits, and time slicing - Ratio here: ~1.86 context switches per interrupt</p> <p>CPU and Core Detection: - vmstat shows combined CPU statistics across all cores - Cannot directly determine CPU/core count from vmstat output - Use these commands for CPU/core information:   <code>bash   nproc                    # Total processing units   lscpu                    # Detailed CPU architecture   cat /proc/cpuinfo        # Per-core details</code></p> <p>Analysis of example output: - Light system load (r=1, low context switches) - Minimal swapping (si=so=0) - Low I/O activity (bi=8, bo=12) - CPU mostly idle (id=97%) indicating good availability</p>"},{"location":"linux/commands-reference/#process-memory-information","title":"Process Memory Information","text":""},{"location":"linux/commands-reference/#procselfmaps","title":"<code>/proc/self/maps</code>","text":"<p>Memory mapping of current process.</p> <pre><code>cat /proc/self/maps\n</code></pre> <p>Shows virtual memory areas, permissions, and backing files.</p>"},{"location":"linux/commands-reference/#pmap","title":"<code>pmap $$</code>","text":"<p>Display memory map of current shell process.</p> <pre><code>pmap $$\n</code></pre> <p>Shows detailed memory layout of the specified process.</p>"},{"location":"linux/commands-reference/#network-internals","title":"Network Internals","text":""},{"location":"linux/commands-reference/#network-interface-commands","title":"Network Interface Commands","text":""},{"location":"linux/commands-reference/#ip-addr-show","title":"<code>ip addr show</code>","text":"<p>Display network interface information.</p> <pre><code>ip addr show\n</code></pre> <p>Example output:</p> <pre><code>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP\n    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff\n    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0\n</code></pre>"},{"location":"linux/commands-reference/#ip-route-show","title":"<code>ip route show</code>","text":"<p>Display routing table.</p> <pre><code>ip route show\n</code></pre> <p>Shows how network traffic is routed.</p>"},{"location":"linux/commands-reference/#netstat-tuln","title":"<code>netstat -tuln</code>","text":"<p>Show listening ports and network connections.</p> <pre><code>netstat -tuln\n</code></pre> <p>Flags:</p> <ul> <li>-t: TCP connections</li> <li>-u: UDP connections</li> <li>-l: Listening ports only</li> <li>-n: Numerical addresses instead of hostnames</li> </ul>"},{"location":"linux/commands-reference/#ss-tuln","title":"<code>ss -tuln</code>","text":"<p>Modern replacement for netstat.</p> <pre><code>ss -tuln\n</code></pre> <p>Faster and more feature-rich than netstat.</p>"},{"location":"linux/commands-reference/#network-statistics","title":"Network Statistics","text":""},{"location":"linux/commands-reference/#procnetdev","title":"<code>/proc/net/dev</code>","text":"<p>Network interface statistics.</p> <pre><code>cat /proc/net/dev\n</code></pre> <p>Example output:</p> <pre><code>Inter-|   Receive                                                |  Transmit\n face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed\n    lo: 1728      24    0    0    0     0          0         0     1728      24    0    0    0     0       0          0\n  eth0: 2847234   1842    0    0    0     0          0         0   156742     876    0    0    0     0       0          0\n</code></pre>"},{"location":"linux/commands-reference/#procnettcp","title":"<code>/proc/net/tcp</code>","text":"<p>TCP connection information.</p> <pre><code>cat /proc/net/tcp\n</code></pre> <p>Shows active TCP connections with socket states.</p>"},{"location":"linux/commands-reference/#file-system-and-io","title":"File System and I/O","text":""},{"location":"linux/commands-reference/#io-statistics","title":"I/O Statistics","text":""},{"location":"linux/commands-reference/#iostat","title":"<code>iostat</code>","text":"<p>Display I/O statistics for devices and partitions.</p> <pre><code>iostat\n</code></pre> <p>Key metrics:</p> <ul> <li>%user: CPU time in user mode</li> <li>%system: CPU time in system mode</li> <li>%iowait: CPU time waiting for I/O</li> <li>tps: Transfers per second</li> <li>kB_read/s, kB_wrtn/s: Data read/written per second</li> </ul>"},{"location":"linux/commands-reference/#procdiskstats","title":"<code>/proc/diskstats</code>","text":"<p>Disk I/O statistics.</p> <pre><code>cat /proc/diskstats\n</code></pre> <p>Raw disk statistics used by tools like iostat.</p>"},{"location":"linux/commands-reference/#file-system-information","title":"File System Information","text":""},{"location":"linux/commands-reference/#procfilesystems","title":"<code>/proc/filesystems</code>","text":"<p>Supported filesystem types.</p> <pre><code>cat /proc/filesystems\n</code></pre> <p>Lists filesystem types supported by the kernel.</p>"},{"location":"linux/commands-reference/#findmnt","title":"<code>findmnt</code>","text":"<p>Display mounted filesystems in tree format.</p> <pre><code>findmnt\n</code></pre> <p>Modern tool for displaying mount information.</p>"},{"location":"linux/commands-reference/#stat-etcpasswd","title":"<code>stat /etc/passwd</code>","text":"<p>Display detailed file information.</p> <pre><code>stat /etc/passwd\n</code></pre> <p>Example output:</p> <pre><code>  File: /etc/passwd\n  Size: 2956        Blocks: 8          IO Block: 4096   regular file\nDevice: 801h/2049d  Inode: 131588      Links: 1\nAccess: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)\nAccess: 2021-06-15 10:30:25.000000000 +0000\nModify: 2021-06-15 10:30:25.000000000 +0000\nChange: 2021-06-15 10:30:25.000000000 +0000\n</code></pre>"},{"location":"linux/commands-reference/#ls-li-etc","title":"<code>ls -li /etc/</code>","text":"<p>List files with inode numbers.</p> <pre><code>ls -li /etc/\n</code></pre> <p>Shows inode numbers along with file details.</p>"},{"location":"linux/commands-reference/#process-tracing","title":"Process Tracing","text":""},{"location":"linux/commands-reference/#system-call-tracing","title":"System Call Tracing","text":""},{"location":"linux/commands-reference/#strace-ls-etc","title":"<code>strace ls /etc/</code>","text":"<p>Trace system calls made by a command.</p> <pre><code>strace ls /etc/\n</code></pre> <p>Shows all system calls made during command execution.</p>"},{"location":"linux/commands-reference/#strace-e-tracefile-ls-etc","title":"<code>strace -e trace=file ls /etc/</code>","text":"<p>Trace only file-related system calls.</p> <pre><code>strace -e trace=file ls /etc/\n</code></pre> <p>Filters to show only file operations (open, read, write, etc.).</p>"},{"location":"linux/commands-reference/#ltrace-ls-etc","title":"<code>ltrace ls /etc/</code>","text":"<p>Trace library function calls.</p> <pre><code>ltrace ls /etc/\n</code></pre> <p>Shows library function calls instead of system calls.</p>"},{"location":"linux/commands-reference/#process-monitoring","title":"Process Monitoring","text":""},{"location":"linux/commands-reference/#watch-n-1-ps-aux-head-20","title":"<code>watch -n 1 'ps aux | head -20'</code>","text":"<p>Monitor top 20 processes, refreshing every second.</p> <pre><code>watch -n 1 'ps aux | head -20'\n</code></pre> <p>Continuously monitors process list with automatic refresh.</p>"},{"location":"linux/commands-reference/#kernel-and-system-calls","title":"Kernel and System Calls","text":""},{"location":"linux/commands-reference/#kernel-modules","title":"Kernel Modules","text":""},{"location":"linux/commands-reference/#lsmod","title":"<code>lsmod</code>","text":"<p>List loaded kernel modules.</p> <pre><code>lsmod\n</code></pre> <p>Example output:</p> <pre><code>Module                  Size  Used by\nfuse                  131072  3\nxt_CHECKSUM            16384  1\nxt_MASQUERADE          20480  3\n</code></pre>"},{"location":"linux/commands-reference/#procmodules","title":"<code>/proc/modules</code>","text":"<p>Kernel modules information.</p> <pre><code>cat /proc/modules\n</code></pre> <p>Detailed information about loaded kernel modules.</p>"},{"location":"linux/commands-reference/#system-information","title":"System Information","text":""},{"location":"linux/commands-reference/#procsyskernelosrelease","title":"<code>/proc/sys/kernel/osrelease</code>","text":"<p>Kernel release information.</p> <pre><code>cat /proc/sys/kernel/osrelease\n</code></pre> <p>Shows kernel version string.</p>"},{"location":"linux/commands-reference/#sysctl-a-grep-vm","title":"<code>sysctl -a | grep vm</code>","text":"<p>Display virtual memory related kernel parameters.</p> <pre><code>sysctl -a | grep vm\n</code></pre> <p>Shows tunable kernel parameters related to virtual memory.</p>"},{"location":"linux/commands-reference/#container-and-namespace-exploration","title":"Container and Namespace Exploration","text":""},{"location":"linux/commands-reference/#namespace-information","title":"Namespace Information","text":""},{"location":"linux/commands-reference/#ls-la-procselfns","title":"<code>ls -la /proc/self/ns/</code>","text":"<p>List namespaces for current process.</p> <pre><code>ls -la /proc/self/ns/\n</code></pre> <p>Example output:</p> <pre><code>lrwxrwxrwx 1 root root 0 Jun 15 10:30 cgroup -&gt; 'cgroup:[4026531835]'\nlrwxrwxrwx 1 root root 0 Jun 15 10:30 ipc -&gt; 'ipc:[4026531839]'\nlrwxrwxrwx 1 root root 0 Jun 15 10:30 mnt -&gt; 'mnt:[4026531840]'\nlrwxrwxrwx 1 root root 0 Jun 15 10:30 net -&gt; 'net:[4026531992]'\nlrwxrwxrwx 1 root root 0 Jun 15 10:30 pid -&gt; 'pid:[4026531836]'\nlrwxrwxrwx 1 root root 0 Jun 15 10:30 user -&gt; 'user:[4026531837]'\nlrwxrwxrwx 1 root root 0 Jun 15 10:30 uts -&gt; 'uts:[4026531838]'\n</code></pre>"},{"location":"linux/commands-reference/#readlink-procselfns","title":"<code>readlink /proc/self/ns/*</code>","text":"<p>Read namespace identifiers.</p> <pre><code>readlink /proc/self/ns/*\n</code></pre> <p>Shows the actual namespace identifiers.</p>"},{"location":"linux/commands-reference/#cgroup-information","title":"Cgroup Information","text":""},{"location":"linux/commands-reference/#procselfcgroup","title":"<code>/proc/self/cgroup</code>","text":"<p>Control group information for current process.</p> <pre><code>cat /proc/self/cgroup\n</code></pre> <p>Example output:</p> <pre><code>12:cpuset:/\n11:cpu,cpuacct:/\n10:memory:/\n9:devices:/docker/abc123def456\n</code></pre>"},{"location":"linux/commands-reference/#ls-la-sysfscgroup","title":"<code>ls -la /sys/fs/cgroup/</code>","text":"<p>List cgroup filesystem structure.</p> <pre><code>ls -la /sys/fs/cgroup/\n</code></pre> <p>Shows available cgroup controllers and hierarchies.</p>"},{"location":"linux/commands-reference/#usage-tips","title":"Usage Tips","text":"<ol> <li>Combine commands: Use pipes to combine commands for more specific information</li> </ol> <p><code>bash    ps aux | grep nginx    netstat -tuln | grep :80</code></p> <ol> <li>Use watch for monitoring: Add <code>watch</code> to continuously monitor changing values</li> </ol> <p><code>bash    watch -n 2 'free -h'    watch -n 1 'ss -tuln'</code></p> <ol> <li>Filter with grep: Most /proc files can be filtered with grep</li> </ol> <p><code>bash    cat /proc/cpuinfo | grep \"model name\"    cat /proc/meminfo | grep \"Mem\"</code></p> <ol> <li>Save outputs: Redirect output to files for later analysis    <code>bash    ps aux &gt; process_snapshot.txt    dmesg &gt; kernel_messages.log</code></li> </ol> <p>This reference provides a foundation for Linux system administration and troubleshooting. Each command offers different perspectives on system state and behavior, making them valuable tools for SRE work.</p>"},{"location":"linux/interfaces/","title":"\ud83d\udc27 Linux Operating System Interfaces","text":"<p>Based on xv6/x86 architecture Course Reference UCI ICS 143A</p>"},{"location":"linux/interfaces/#interfaces","title":"\ud83d\udd0c Interfaces","text":"<p>An operating system provides services to user programs through an interface that acts as a bridge between applications and system resources.</p> <p></p>"},{"location":"linux/interfaces/#kernel","title":"\u2699\ufe0f Kernel","text":"<p>The kernel is the core interface between a computer's hardware and its processes. It uses the CPU's hardware protection mechanisms to ensure that each process executing in user space can access only its own memory. The kernel executes with the hardware privileges required to implement these protections; user programs execute without those privileges. When a user program invokes a system call, the hardware raises the privilege level and starts executing a pre-arranged function in the kernel.</p>"},{"location":"linux/interfaces/#the-kernels-four-key-responsibilities","title":"\ud83c\udfaf The Kernel's Four Key Responsibilities","text":"<ol> <li> <p>\ud83e\udde0 Memory Management    Keep track of how much memory is used to store what, and where</p> </li> <li> <p>\u26a1 Process Management    Determine which processes can use the central processing unit (CPU), when, and for how long</p> </li> <li> <p>\ud83d\udd27 Device Drivers    Act as mediator/interpreter between the hardware and processes</p> </li> <li> <p>\ud83d\udd12 System Calls and Security    Receive requests for service from the processes</p> </li> </ol>"},{"location":"linux/interfaces/#shell","title":"\ud83d\udc1a Shell","text":"<p>The shell is an ordinary program that reads commands from the user and executes them. The fact that the shell is a user program, not part of the kernel, illustrates the power of the system call interface.</p>"},{"location":"linux/interfaces/#process","title":"\ud83d\udd04 Process","text":"<p>Each running program, called a process, has memory containing instructions, data, and a stack: - Instructions implement the program's computation - Data are the variables on which the computation acts - Stack organizes the program's procedure calls</p> <p>A process alternates between executing in user space and kernel space.</p>"},{"location":"linux/interfaces/#system-calls","title":"\ud83d\udcde System Calls","text":"<p>When a process needs to invoke a kernel service, it invokes a procedure call in the operating system interface. The system call enters the kernel; the kernel performs the service and returns.</p>"},{"location":"linux/interfaces/#system-call-reference","title":"\ud83d\udccb System Call Reference","text":"System Call \ud83d\udd0d Description <code>fork()</code> \ud83c\udf74 Create a process <code>exit()</code> \u274c Terminate the current process <code>wait()</code> \u23f3 Wait for a child process to exit <code>kill(pid)</code> \ud83d\udc80 Terminate process pid <code>getpid()</code> \ud83c\udd94 Return the current process's pid <code>sleep(n)</code> \ud83d\udca4 Sleep for n clock ticks <code>exec(filename, *argv)</code> \ud83d\ude80 Load a file and execute it <code>sbrk(n)</code> \ud83d\udcc8 Grow process's memory by n bytes <code>open(filename, flags)</code> \ud83d\udcc2 Open a file; the flags indicate read/write <code>read(fd, buf, n)</code> \ud83d\udcd6 Read n bytes from an open file into buf <code>write(fd, buf, n)</code> \u270d\ufe0f Write n bytes to an open file <code>close(fd)</code> \ud83d\udd12 Release open file fd <code>dup(fd)</code> \ud83d\udccb Duplicate fd <code>pipe(p)</code> \ud83d\udd17 Create a pipe and return fd's in p <code>chdir(dirname)</code> \ud83d\udcc1 Change the current directory <code>mkdir(dirname)</code> \ud83d\udcc1\u2795 Create a new directory <code>mknod(name, major, minor)</code> \ud83d\udee0\ufe0f Create a device file <code>fstat(fd)</code> \u2139\ufe0f Return info about an open file <code>link(f1, f2)</code> \ud83d\udd17 Create another name (f2) for the file f1 <code>unlink(filename)</code> \ud83d\uddd1\ufe0f Remove a file"},{"location":"linux/interfaces/#io-and-file-descriptors","title":"\ud83d\udcc1 I/O and File Descriptors","text":""},{"location":"linux/interfaces/#file-descriptor","title":"\ud83d\udd22 File Descriptor","text":"<p>A file descriptor is a small integer representing a kernel-managed object that a process may read from or write to. A process may obtain a file descriptor by: - Opening a file, directory, or device - Creating a pipe - Duplicating an existing descriptor</p> <p>The file descriptor interface abstracts away the differences between files, pipes, and devices, making them all look like streams of bytes.</p>"},{"location":"linux/interfaces/#standard-file-descriptors","title":"Standard File Descriptors","text":"<ol> <li>fd0 = <code>stdin</code> \ud83d\udce5 (Standard Input)</li> <li>fd1 = <code>stdout</code> \ud83d\udce4 (Standard Output)  </li> <li>fd2 = <code>stderr</code> \ud83d\udea8 (Standard Error)</li> </ol>"},{"location":"linux/interfaces/#pipes","title":"\ud83d\udd17 Pipes","text":"<p>A pipe is a small kernel buffer exposed to processes as a pair of file descriptors: - One for reading \ud83d\udcd6 - One for writing \u270d\ufe0f</p> <p>Writing data to one end of the pipe makes that data available for reading from the other end. Pipes provide a way for processes to communicate.</p>"},{"location":"linux/interfaces/#file-system","title":"\ud83d\uddc2\ufe0f File System","text":"<p>The file system provides:</p> <ul> <li>Data files - uninterpreted byte arrays</li> <li>Directories - contain named references to data files and other directories</li> </ul> <p>The directories form a tree structure, starting at a special directory called the root (<code>/</code>).</p>"},{"location":"linux/interfaces/#inode","title":"\ud83d\udcc7 Inode","text":"<p>An inode (index node) represents the underlying file structure. Key concepts:</p> <ul> <li>A file's name is distinct from the file itself</li> <li>The same underlying file (inode) can have multiple names, called links</li> <li>The <code>link()</code> system call creates another filename referring to the same inode</li> <li>Inodes do not store actual data - they store metadata indicating where to find the storage blocks of each file's data</li> </ul>"},{"location":"linux/linux-questions/","title":"MongoDB SRE Interview - Complete Study Guide","text":""},{"location":"linux/linux-questions/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Interview Overview</li> <li>Linux Fundamentals</li> <li>Networking Fundamentals</li> <li>Troubleshooting Scenarios</li> <li>Essential Commands Reference</li> <li>Common Interview Traps</li> <li>Communication Tips</li> </ol>"},{"location":"linux/linux-questions/#interview-overview","title":"Interview Overview","text":""},{"location":"linux/linux-questions/#format-60-minutes","title":"Format (60 minutes)","text":"<ul> <li>Coding (30 min): Language-agnostic practical problems</li> <li>Linux/Networking (30 min): Q&amp;A focused on conceptual understanding</li> </ul>"},{"location":"linux/linux-questions/#linuxnetworking-focus","title":"Linux/Networking Focus","text":"<ul> <li>File systems (inodes, links, permissions)</li> <li>Process signals and states</li> <li>Shell behavior (globbing, parsing)</li> <li>TCP/UDP protocols</li> <li>Load balancing</li> <li>TLS basics</li> </ul>"},{"location":"linux/linux-questions/#linux-fundamentals","title":"Linux Fundamentals","text":""},{"location":"linux/linux-questions/#file-system-operations","title":"File System Operations","text":""},{"location":"linux/linux-questions/#what-happens-when-you-run-rm-filename","title":"What Happens When You Run <code>rm filename</code>","text":"<p>Process Flow:</p> <ol> <li>Shell locates <code>rm</code> binary via $PATH</li> <li>Shell forks, child process exec's <code>rm</code></li> <li><code>rm</code> calls <code>unlink()</code> system call</li> <li>Directory entry (linking filename to inode) is removed</li> <li>Inode's link count is decremented</li> <li>If link count = 0 AND no processes have file open:</li> <li>Inode and data blocks marked as free in filesystem bitmaps</li> <li>If processes still have file open:</li> <li>Deletion deferred until last file descriptor closes</li> <li>Data isn't immediately overwritten (why file recovery works)</li> </ol> <p>Key Points:</p> <ul> <li>No signals involved (SIGTERM is for killing processes, not files)</li> <li>Filename lives in directory entry, not inode</li> <li>Inode contains: metadata, permissions, timestamps, pointers to data blocks</li> </ul>"},{"location":"linux/linux-questions/#hard-links-vs-symbolic-links","title":"Hard Links vs Symbolic Links","text":"Feature Hard Link Symbolic Link (Symlink) What it is Directory entry pointing to inode Special file containing path string Inode Shares same inode as target Has its own inode After deleting target Still works (shares inode) Becomes \"dangling\" (broken link) Cross filesystem \u274c No (different inode tables) \u2705 Yes Link to directories \u274c No (prevents cycles) \u2705 Yes Visibility Looks like regular file Shows as lrwxrwxrwx with -&gt; target <p>Commands:</p> <pre><code># Hard link\nln file1.txt file2.txt\nls -i file1.txt file2.txt  # Same inode number\n\n# Symbolic link\nln -s file1.txt file2_link\nls -i file1.txt file2_link  # Different inode numbers\n</code></pre> <p>When target is deleted:</p> <ul> <li>Hard link: Continues to work (both are equal directory entries)</li> <li>Symlink: Breaks (path no longer exists)</li> </ul>"},{"location":"linux/linux-questions/#recovering-from-chmod-000-binchmod","title":"Recovering from <code>chmod 000 /bin/chmod</code>","text":"<p>Problem: Even root cannot execute a file with no execute permissions.</p> <p>Solutions (in order of preference):</p> <pre><code># Method 1: Use Python (quickest)\npython3 -c \"import os; os.chmod('/bin/chmod', 0o755)\"\n\n# Method 2: Use Perl\nperl -e 'chmod 0755, \"/bin/chmod\"'\n\n# Method 3: Use busybox\nbusybox chmod 755 /bin/chmod\n\n# Method 4: Use install command\ninstall -m 755 /bin/chown /tmp/chmod_backup\ninstall -m 755 /tmp/chmod_backup /bin/chmod\n\n# Method 5: Copy from another location\ncp /usr/bin/chmod /bin/chmod  # If available elsewhere\n</code></pre> <p>Why this works: Interpreted languages call <code>chmod()</code> system call directly without needing to execute the <code>/bin/chmod</code> binary.</p>"},{"location":"linux/linux-questions/#process-management","title":"Process Management","text":""},{"location":"linux/linux-questions/#process-states","title":"Process States","text":"State Symbol Description Can Kill? Running R Executing or ready to run \u2705 Yes Sleeping (Interruptible) S Waiting for event, can be interrupted \u2705 Yes Sleeping (Uninterruptible) D Waiting for I/O, cannot be interrupted \u274c No Zombie Z Terminated but not reaped by parent \u274c No (already dead) Stopped T Paused by signal (SIGSTOP/SIGTSTP) \u2705 Yes"},{"location":"linux/linux-questions/#the-d-state-problem","title":"The D State Problem","text":"<p>What it means:</p> <ul> <li>Process stuck in kernel space waiting for I/O</li> <li>Cannot receive signals (including SIGKILL)</li> <li>Usually lasts milliseconds; hours = serious problem</li> </ul> <p>Common Causes:</p> <ol> <li>Hung NFS mount (most common)</li> <li>Failing disk hardware</li> <li>Overloaded storage backend</li> <li>Kernel bug or driver issue</li> </ol> <p>Investigation Steps:</p> <pre><code># 1. Find processes in D state\nps aux | awk '$8 ~ /D/ {print}'\nps -eo pid,stat,comm,wchan | grep \"^[0-9]* D\"\n\n# 2. Check what it's waiting for (WCHAN column)\n# Common values:\n# - nfs_sync_inode_wait: NFS issue\n# - wait_on_page_writeback: Disk write\n# - io_schedule: Generic I/O wait\n\n# 3. See what files are open\nsudo lsof -p &lt;PID&gt;\n\n# 4. Check kernel stack trace\nsudo cat /proc/&lt;PID&gt;/stack\n\n# 5. I/O investigation\niostat -x 1 5    # Look for %util at 100%, high await\nsudo iotop -o    # Per-process I/O\ncat /proc/&lt;PID&gt;/io\n\n# 6. Check mount points\nmount | grep nfs\ntimeout 5 ls -l /nfs/mount/point  # Test if responsive\ndmesg | grep -i \"stale\\|nfs\"\n\n# 7. Hardware issues\ndmesg | grep -i \"error\\|fail\\|ata\\|scsi\"\nsudo smartctl -a /dev/sda\n</code></pre> <p>Can you kill it?</p> <ul> <li>Direct answer: NO</li> <li>Signals only delivered when process returns to user space</li> <li>Process is stuck in kernel space</li> </ul> <p>Solutions:</p> <pre><code># Fix the underlying I/O issue\nsudo umount -f /nfs/mount   # Force unmount NFS\nsudo umount -l /nfs/mount   # Lazy unmount\n\n# For NFS, use soft mounts in future\nmount -t nfs -o soft,timeo=10,intr server:/export /mnt\n\n# Last resort: Reboot (but fix root cause!)\n</code></pre>"},{"location":"linux/linux-questions/#signals","title":"Signals","text":"Signal Number Default Action Can Catch? Use Case SIGTERM 15 Terminate \u2705 Yes Graceful shutdown (default) SIGKILL 9 Terminate \u274c No Force kill SIGSTOP 19 Stop \u274c No Pause process SIGCONT 18 Continue \u2705 Yes Resume stopped process SIGTSTP 20 Stop \u2705 Yes Ctrl+Z (can catch for cleanup) SIGINT 2 Terminate \u2705 Yes Ctrl+C (interrupt) SIGHUP 1 Terminate \u2705 Yes Hangup / reload config <p>Important Corrections:</p> <ul> <li>SIGINT does NOT pause - it requests termination</li> <li>SIGSTOP/SIGTSTP pause processes</li> <li>SIGTERM is graceful, SIGKILL is forceful</li> </ul> <p>Commands:</p> <pre><code>kill -l                    # List all signals\nkill PID                   # SIGTERM (default, graceful)\nkill -TERM PID            # Same as above\nkill -KILL PID            # Force kill (cannot be caught)\nkill -9 PID               # Same as SIGKILL\nkill -STOP PID            # Pause\nkill -CONT PID            # Resume\nkill -HUP PID             # Reload config (many daemons support this)\n\n# Process groups (negative PID)\nkill -TERM -1234          # Kill entire process group 1234\n</code></pre>"},{"location":"linux/linux-questions/#process-group-signals","title":"Process Group Signals","text":"<p>Difference between <code>kill PID</code> and <code>kill -PID</code>:</p> <pre><code># kill PID: Send signal to single process\nkill -TERM 1234\n\n# kill -PID: Send signal to entire process group\nkill -TERM -1234\n\n# This kills parent AND all children with same PGID\n</code></pre> <p>When to use process groups:</p> <ul> <li>Killing parent with all children (shell scripts with subprocesses)</li> <li>Stopping entire job (terminal job control)</li> <li>Related to terminal sessions and <code>nohup</code></li> </ul> <p>Terminal sessions:</p> <pre><code># When you logout, terminal sends SIGHUP to session leader\n# Session leader forwards to process group\n# All processes in group receive SIGHUP\n\n# nohup protects from this:\nnohup ./long_running_script.sh &amp;\n# Process ignores SIGHUP, survives logout\n\n# Alternative: disown\n./script.sh &amp;\ndisown\n\n# Or use screen/tmux\nscreen -S mysession\n# Detach with Ctrl+A, D\n# Reattach with: screen -r mysession\n</code></pre>"},{"location":"linux/linux-questions/#investigating-high-cpu-usage","title":"Investigating High CPU Usage","text":"<p>Systematic Approach:</p> <pre><code># Step 1: Identify the process\ntop -o %CPU\nhtop\nps aux --sort=-%cpu | head -n 10\n\n# Note: %CPU can exceed 100% on multi-core\n# 400% = using 4 cores fully\n\n# Step 2: Get process details\ncat /proc/PID/status\ncat /proc/PID/cmdline | tr '\\0' ' '\nps -p PID -o args\n\n# Step 3: Understand what it's doing\nstrace -c -p PID  # System call summary\n# High CPU with few syscalls = pure computation/infinite loop\n\n# Step 4: Stack trace\npstack PID           # C/C++\njstack PID           # Java\npy-spy dump -p PID   # Python\n\n# Step 5: Check threads\nps -T -p PID\ntop -H -p PID\ncat /proc/PID/task/*/status | grep -E \"^(Name|State):\"\n\n# Step 6: Profile the application\nperf top -p PID\nperf record -p PID -g\nperf report\n\n# Step 7: Check system resources\nvmstat 1\n# us = user CPU, sy = system CPU\n# id = idle, wa = I/O wait\n\nmpstat -P ALL 1      # Per-core CPU\npidstat -w -p PID 1  # Context switches\niotop -p PID         # I/O activity\n</code></pre> <p>Common Causes:</p> <ul> <li>Infinite loop or logic bug (high CPU, minimal syscalls)</li> <li>Inefficient algorithm (O(n\u00b2) processing large dataset)</li> <li>Busy-wait polling loop</li> <li>Lock contention in multi-threaded app</li> </ul>"},{"location":"linux/linux-questions/#disk-space-issues","title":"Disk Space Issues","text":""},{"location":"linux/linux-questions/#disk-full-but-df-h-shows-space","title":"Disk Full but <code>df -h</code> Shows Space","text":"<p>Common Scenarios:</p> <p>1. Deleted Files Still Open (Most Common)</p> <pre><code># Problem: File deleted but process still has it open\n# df counts it, du doesn't see it\n\n# Find them:\nlsof +L1\nlsof | grep deleted\n\n# Example output:\n# java  1234  app  10w  REG  253,1  5.0G  0  /var/log/app.log (deleted)\n\n# Solutions:\n# Option 1: Restart the process\nsystemctl restart application\n\n# Option 2: Truncate the file descriptor\ntruncate -s 0 /proc/PID/fd/FD_NUMBER\n\n# Option 3: Send SIGHUP (many daemons reopen logs)\nkill -HUP PID\n</code></pre> <p>2. Inode Exhaustion</p> <pre><code># Check inode usage\ndf -i\n\n# Output showing problem:\n# Filesystem      Inodes   IUsed   IFree IUse% Mounted on\n# /dev/sda1      3276800 3276800       0  100% /\n\n# Find directories with most files:\nfor dir in /*; do\n  echo -n \"$dir: \";\n  find \"$dir\" -type f | wc -l;\ndone | sort -t: -k2 -n\n\n# Or:\nfind / -xdev -printf '%h\\n' | sort | uniq -c | sort -k 1 -n\n</code></pre> <p>3. Reserved Blocks</p> <pre><code># Ext filesystems reserve ~5% for root\ntune2fs -l /dev/sda1 | grep -i \"reserved block\"\n\n# Non-root users see \"disk full\"\n# Root sees available space\n</code></pre> <p>4. Hidden Mount Points</p> <pre><code># Data written before mount is hidden but uses space\necho \"hidden\" &gt; /mnt/test.txt\nmount /dev/sdb1 /mnt    # Hides test.txt\n\n# To find:\numount /mnt\nls /mnt                 # Now you see hidden files\n</code></pre> <p>Debugging Script:</p> <pre><code>#!/bin/bash\n# Quick disk space diagnostic\n\necho \"=== Disk Space ===\"\ndf -h /\n\necho -e \"\\n=== Inode Usage ===\"\ndf -i /\n\necho -e \"\\n=== Deleted but Open Files ===\"\nlsof +L1 2&gt;/dev/null | grep -v \"0t0\" | grep \"REG\"\n\necho -e \"\\n=== Largest Directories ===\"\ndu -sh /* 2&gt;/dev/null | sort -h | tail -10\n\necho -e \"\\n=== Compare df vs du ===\"\necho \"df reports: $(df -h / | tail -1 | awk '{print $3}') used\"\necho \"du reports: $(du -sh / 2&gt;/dev/null | awk '{print $1}') used\"\n</code></pre>"},{"location":"linux/linux-questions/#networking-fundamentals","title":"Networking Fundamentals","text":""},{"location":"linux/linux-questions/#tcp-three-way-handshake","title":"TCP Three-Way Handshake","text":"<p>The Process:</p> <pre><code>Client                          Server\n  |                               |\n  |  [1] SYN (seq=X)             |\n  |-----------------------------&gt;|  State: LISTEN \u2192 SYN-RECEIVED\n  |  State: SYN-SENT             |\n  |                              |\n  |  [2] SYN-ACK (seq=Y, ack=X+1)|\n  |&lt;-----------------------------|\n  |                              |\n  |  [3] ACK (seq=X+1, ack=Y+1)  |\n  |-----------------------------&gt;|\n  |                              |\n  (State: ESTABLISHED)      (State: ESTABLISHED)\n</code></pre> <p>What Each Step Does:</p> <ol> <li> <p>Client sends SYN:</p> </li> <li> <p>Includes initial sequence number (ISN) = X</p> </li> <li>Client enters SYN-SENT state</li> <li> <p>\"I want to connect, here's my starting sequence\"</p> </li> <li> <p>Server sends SYN-ACK:</p> </li> <li> <p>Server's sequence number = Y</p> </li> <li>Acknowledgment = X+1</li> <li>Server enters SYN-RECEIVED state</li> <li> <p>\"Got your SYN, here's my starting sequence\"</p> </li> <li> <p>Client sends ACK:</p> </li> <li>Sequence = X+1, Acknowledgment = Y+1</li> <li>Both enter ESTABLISHED state</li> <li>\"Got your SYN-ACK, let's send data\"</li> </ol>"},{"location":"linux/linux-questions/#if-syn-ack-is-lost","title":"If SYN-ACK is Lost","text":"<p>What Happens:</p> <pre><code>Client                          Server\n  |  [1] SYN (seq=X)             |\n  |-----------------------------&gt;|\n  |  [2] SYN-ACK \u2717\u2717\u2717 LOST \u2717\u2717\u2717    |\n  |                              |\n  | ... timeout (1-3 seconds)... | (Server waiting in SYN-RECEIVED)\n  |                              |\n  |  [1] SYN RETRANSMIT          |\n  |-----------------------------&gt;|\n  |  [2] SYN-ACK                 |\n  |&lt;-----------------------------|\n  |  [3] ACK                     |\n  |-----------------------------&gt;|\n</code></pre> <p>Key Points:</p> <ul> <li>Client's retransmission timer expires</li> <li>Client retransmits the same SYN (same seq=X)</li> <li>Exponential backoff: 1s, 2s, 4s, 8s, 16s, 32s...</li> <li>After 5-6 attempts (configurable), gives up</li> <li>Server also has timer for missing ACK</li> <li>No data flows until handshake completes</li> </ul> <p>Tuning:</p> <pre><code># Number of SYN retries before giving up\ncat /proc/sys/net/ipv4/tcp_syn_retries  # Default: 6\n</code></pre>"},{"location":"linux/linux-questions/#tcp-vs-udp","title":"TCP vs UDP","text":""},{"location":"linux/linux-questions/#tcp-retransmission","title":"TCP Retransmission","text":"<p>How it Works:</p> <ul> <li>TCP is reliable and connection-oriented</li> <li>Every segment has a sequence number</li> <li>Receiver sends ACKs for received segments</li> <li>Sender maintains retransmission timer for unacked segments</li> </ul> <p>When Retransmission Happens:</p> <ol> <li>Timeout: ACK not received before timer expires</li> <li>Duplicate ACKs: Receiver sends duplicate ACKs when gap detected</li> <li>3 duplicate ACKs trigger fast retransmit</li> </ol> <p>What Gets Retransmitted:</p> <ul> <li>Exact same segment with same sequence number</li> <li>Receiver uses sequence numbers to:</li> <li>Reassemble data in order</li> <li>Detect and discard duplicates</li> </ul> <p>Performance Impact:</p> <ul> <li>Reduces throughput</li> <li>TCP adjusts congestion window</li> <li>RTT (Round Trip Time) affects retransmission delay</li> </ul> <p>Causes:</p> <ul> <li>Network congestion</li> <li>Packet corruption</li> <li>Packet loss</li> <li>Out-of-order delivery</li> </ul>"},{"location":"linux/linux-questions/#udp-packet-loss","title":"UDP Packet Loss","text":"<p>How it Works:</p> <ul> <li>UDP is unreliable and connectionless</li> <li>No acknowledgments, no sequence numbers</li> <li>No retransmission at transport layer</li> <li>Sender has no idea packet was lost</li> </ul> <p>When Packets Are Lost:</p> <ul> <li>Sender doesn't know</li> <li>Receiver simply never gets data</li> <li>No automatic recovery</li> </ul> <p>Application Responsibility:</p> <ul> <li>If reliability needed, app must implement it</li> <li>Examples:</li> <li>QUIC (HTTP/3): Reliability over UDP</li> <li>RTP (VoIP): Uses sequence numbers but may not retransmit</li> <li>DNS: Application-level retry after timeout</li> </ul> <p>Why Use UDP Despite Loss:</p> <ol> <li>Lower latency (no connection setup, no ACK waiting)</li> <li>Less overhead (8-byte header vs 20+ for TCP)</li> <li>Better for real-time (old data is useless in live video)</li> <li>Multicast/broadcast capable</li> </ol> <p>Use Cases:</p> <ul> <li>DNS queries (retry is fine)</li> <li>VoIP/video streaming (some loss acceptable)</li> <li>Gaming (speed &gt; perfect accuracy)</li> <li>DHCP (simple request/response)</li> </ul>"},{"location":"linux/linux-questions/#tcp-connection-states","title":"TCP Connection States","text":"State Description LISTEN Server waiting for connections SYN-SENT Client sent SYN, waiting for SYN-ACK SYN-RECEIVED Server sent SYN-ACK, waiting for ACK ESTABLISHED Connection active, data flowing FIN-WAIT-1 Sent FIN, waiting for ACK FIN-WAIT-2 Received ACK of FIN, waiting for peer's FIN TIME-WAIT Connection closed, waiting for stray packets (2MSL) CLOSE-WAIT Peer closed connection, local not yet closed LAST-ACK Sent FIN after CLOSE-WAIT, waiting for ACK CLOSING Both sides closing simultaneously <p>Important States:</p> <ul> <li>CLOSE-WAIT: Application not closing sockets properly</li> <li>TIME-WAIT: Normal after connection close (prevents packet confusion)</li> </ul>"},{"location":"linux/linux-questions/#netstat-vs-ss","title":"netstat vs ss","text":"Feature netstat ss Speed Slow (reads /proc) Fast (netlink sockets) Data Source /proc/net/* files Direct kernel query Performance Heavy with many connections Minimal overhead Status Legacy/deprecated Actively maintained Filtering Limited (need grep) Built-in powerful filters TCP Details Basic Detailed (RTT, cwnd, retrans) <p>Basic Usage:</p> <pre><code># List all TCP/UDP listening ports\nnetstat -tuln\nss -tuln\n\n# With process information (requires root)\nsudo netstat -tulnp\nsudo ss -tulnp\n\n# All connections (listening + established)\nnetstat -tuan\nss -tuan\n</code></pre> <p>ss Advanced Features:</p> <pre><code># Extended TCP information\nss -ti\n\n# Output includes:\n# - rto: Retransmission timeout\n# - rtt: Round-trip time\n# - cwnd: Congestion window\n# - bytes_retrans: Retransmitted bytes\n# - send rate, delivery rate\n\n# Powerful filtering\nss -tn dst :443                    # Connections to port 443\nss -tn src 192.168.1.100          # From specific IP\nss -tn state established          # Only established\nss -tn state time-wait            # Only TIME-WAIT\nss -tn '( dport = :80 or dport = :443 )' state established\n\n# Summary statistics\nss -s\n\n# Memory usage per socket\nss -tm\n\n# Timers\nss -to\n</code></pre> <p>Performance Comparison:</p> <pre><code># On system with 50,000 connections:\ntime netstat -tan &gt; /dev/null\n# real    0m2.341s\n\ntime ss -tan &gt; /dev/null\n# real    0m0.123s\n</code></pre> <p>When to Use:</p> <ul> <li>netstat: Legacy systems, quick routing table checks</li> <li>ss: Modern systems (faster, more powerful), production troubleshooting, detailed TCP metrics</li> </ul>"},{"location":"linux/linux-questions/#troubleshooting-scenarios","title":"Troubleshooting Scenarios","text":""},{"location":"linux/linux-questions/#connection-reset-by-peer","title":"Connection Reset by Peer","text":"<p>What RST Means:</p> <ul> <li>TCP RST packet abruptly closes connection</li> <li>No graceful FIN handshake</li> <li>Connection immediately destroyed</li> </ul> <p>Common Causes:</p> <ol> <li>Application explicitly closed connection</li> <li>Firewall actively rejecting</li> <li>Connection tracking table full</li> <li>Kernel limits (file descriptors, socket buffers)</li> <li>TCP backlog full</li> </ol>"},{"location":"linux/linux-questions/#diagnostic-flow","title":"Diagnostic Flow","text":"<p>Step 1: Capture the RST</p> <pre><code># Capture RST packets\nsudo tcpdump -i any -nn 'tcp[tcpflags] &amp; tcp-rst != 0' -w rst.pcap\n\n# Specific port\nsudo tcpdump -i any -nn port 8080 and 'tcp[tcpflags] &amp; tcp-rst != 0'\n\n# Analyze\ntcpdump -r rst.pcap -vvv -nn\n\n# Look for:\n# - Which side sent RST (client or server)\n# - When in connection lifecycle\n# - Sequence number issues\n</code></pre> <p>Step 2: Check Application</p> <pre><code># Application running?\nsystemctl status myapp\nps aux | grep myapp\n\n# Application logs\njournalctl -u myapp -f --since \"5 minutes ago\"\n\n# Look for:\n# - \"Connection closed\", \"Timeout\"\n# - \"Too many connections\"\n# - Exception traces\n\n# Metrics (if available)\ncurl http://localhost:8080/metrics\n</code></pre> <p>Step 3: Check Connection Tracking</p> <pre><code># Current count vs maximum\ncat /proc/sys/net/netfilter/nf_conntrack_count\ncat /proc/sys/net/netfilter/nf_conntrack_max\n\n# Usage percentage\necho \"scale=2; $(cat /proc/sys/net/netfilter/nf_conntrack_count) / $(cat /proc/sys/net/netfilter/nf_conntrack_max) * 100\" | bc\n\n# If close to 100%, this is likely the problem!\n\n# Statistics\ncat /proc/net/stat/nf_conntrack\n# Look for 'drop' or 'early_drop' increasing\n\n# View table\nconntrack -L | head -20\n\n# Count by state\nconntrack -L | awk '{print $4}' | sort | uniq -c | sort -rn\n\n# Temporary fix:\nsudo sysctl -w net.netfilter.nf_conntrack_max=262144\n\n# Permanent in /etc/sysctl.conf:\nnet.netfilter.nf_conntrack_max = 262144\n</code></pre> <p>Step 4: Check Firewall</p> <pre><code># Check for REJECT/DROP rules\nsudo iptables -L -n -v | grep -E \"REJECT|DROP\"\n\n# Specific chains\nsudo iptables -L INPUT -n -v\nsudo iptables -L FORWARD -n -v\n\n# Count dropped packets\nsudo iptables -L -n -v -Z  # Zero counters\n# Wait, then check again\nsudo iptables -L -n -v\n\n# Rate limiting\nsudo iptables -L -n -v | grep limit\n</code></pre> <p>Step 5: Check with ss</p> <pre><code># Retransmissions\nss -ti | grep bytes_retrans | grep -v \"bytes_retrans:0\"\n\n# Connection states\nss -tan state established | wc -l\nss -tan state time-wait | wc -l\nss -tan state close-wait | wc -l   # Many = app not closing sockets\n\n# Summary statistics\nss -s\n# Look for:\n# - TCPBacklogDrop\n# - ListenDrops\n# - TCPTimeouts\n</code></pre> <p>Step 6: Check Kernel Limits</p> <pre><code># File descriptors\nulimit -n\ncat /proc/sys/fs/file-nr\n\n# Socket buffers\nsysctl net.ipv4.tcp_rmem\nsysctl net.ipv4.tcp_wmem\n\n# TCP backlog\nsysctl net.ipv4.tcp_max_syn_backlog\nsysctl net.core.somaxconn\n\n# Statistics\nnetstat -s | grep -i drop\nnetstat -s | grep -i listen\n</code></pre>"},{"location":"linux/linux-questions/#distinguishing-between-causes","title":"Distinguishing Between Causes","text":"<p>Application Issue:</p> <ul> <li>RST in middle of established connection</li> <li>Application logs show errors</li> <li>Happens under load or after timeout</li> <li>Many CLOSE-WAIT states</li> </ul> <p>Firewall Issue:</p> <ul> <li>RST immediately after SYN or early</li> <li>iptables counters show REJECT/DROP increasing</li> <li>Consistent from certain IPs</li> <li>RST from server IP (not app process)</li> </ul> <p>Connection Tracking Full:</p> <ul> <li>nf_conntrack_count \u2248 nf_conntrack_max</li> <li>Intermittent during high traffic</li> <li>dmesg shows \"table full\" messages</li> <li>Sudden RST on established connections</li> </ul> <p>Kernel Limits:</p> <ul> <li>netstat -s shows backlog/listen drops</li> <li>File descriptor limits reached</li> <li>Happens under high connection rate</li> </ul>"},{"location":"linux/linux-questions/#quick-diagnostic-script","title":"Quick Diagnostic Script","text":"<pre><code>#!/bin/bash\necho \"=== Connection Tracking ===\"\necho \"Count: $(cat /proc/sys/net/netfilter/nf_conntrack_count)\"\necho \"Max: $(cat /proc/sys/net/netfilter/nf_conntrack_max)\"\necho \"Usage: $(echo \"scale=2; $(cat /proc/sys/net/netfilter/nf_conntrack_count) / $(cat /proc/sys/net/netfilter/nf_conntrack_max) * 100\" | bc)%\"\n\necho -e \"\\n=== TCP Socket States ===\"\nss -tan | awk '{print $1}' | sort | uniq -c\n\necho -e \"\\n=== Netstat Drops ===\"\nnetstat -s | grep -i \"drop\\|overflow\"\n\necho -e \"\\n=== Recent Kernel Messages ===\"\ndmesg | tail -20\n\necho -e \"\\n=== Firewall Drops ===\"\niptables -L -n -v | grep -E \"DROP|REJECT\" | head -10\n</code></pre>"},{"location":"linux/linux-questions/#essential-commands-reference","title":"Essential Commands Reference","text":""},{"location":"linux/linux-questions/#process-investigation","title":"Process Investigation","text":"<pre><code>ps aux --sort=-%cpu              # CPU hogs\nps aux --sort=-%mem              # Memory hogs\nps -eLf                          # All threads\nps -o ppid= -p PID               # Get parent PID\npgrep -a process_name            # Find by name\npidof process_name               # Get PID\n/proc/PID/status                 # Detailed info\n/proc/PID/cmdline                # Command line\n/proc/PID/fd/                    # Open file descriptors\nlsof -p PID                      # Open files\nstrace -c -p PID                 # System call summary\npstack PID                       # Stack trace\n</code></pre>"},{"location":"linux/linux-questions/#signals_1","title":"Signals","text":"<pre><code>kill -l                          # List all signals\nkill -TERM PID                   # Graceful (15)\nkill -KILL PID                   # Force (9)\nkill -STOP PID                   # Pause (19)\nkill -CONT PID                   # Resume (18)\nkill -HUP PID                    # Reload config (1)\nkillall process_name             # Kill by name\npkill -f \"pattern\"               # Kill by pattern\nkill -TERM -PGID                 # Kill process group\n</code></pre>"},{"location":"linux/linux-questions/#file-system","title":"File System","text":"<pre><code>df -h                            # Disk space\ndf -i                            # Inode usage\ndu -sh /*                        # Directory sizes\nlsof +L1                         # Deleted but open\nlsof | grep deleted              # Alternative\nstat filename                    # File metadata\nls -i                            # Show inode numbers\nfind / -inum INODE               # Find by inode\ntune2fs -l /dev/sda1             # Filesystem info\n</code></pre>"},{"location":"linux/linux-questions/#network-basic","title":"Network - Basic","text":"<pre><code>ss -tulnp                        # All listening\nss -tanp                         # All connections\nss -s                            # Summary stats\nss -ti                           # TCP details\nss 'sport = :80'                 # Filter by port\nss state established             # By state\nping -c 4 host                   # Connectivity\ntraceroute host                  # Path\nmtr host                         # Combined ping/trace\n</code></pre>"},{"location":"linux/linux-questions/#network-advanced","title":"Network - Advanced","text":"<pre><code>ip addr show                     # Interfaces\nip -s link                       # Interface stats\nip route show                    # Routing table\nnetstat -s                       # Protocol stats\ntcpdump -i any host X            # Packet capture\ntcpdump -nn port 443             # Specific port\nlsof -i :PORT                    # What's using port\nnc -zv host port                 # Test connection\ndig domain                       # DNS lookup\nconntrack -L                     # Connection tracking table\n</code></pre>"},{"location":"linux/linux-questions/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code>top / htop                       # Real-time overview\nvmstat 1                         # Virtual memory\niostat -x 1                      # Disk I/O\nmpstat -P ALL 1                  # Per-CPU stats\nsar -u 1 10                      # Historical CPU\niotop                            # I/O by process\niftop                            # Network by connection\ndstat                            # Combined view\n</code></pre>"},{"location":"linux/linux-questions/#system-information","title":"System Information","text":"<pre><code>uname -a                         # Kernel version\ncat /etc/os-release              # OS version\nlscpu                            # CPU info\nfree -h                          # Memory\nuptime                           # Load average\ndmesg | tail                     # Kernel messages\njournalctl -xe                   # System logs\nsystemctl status service         # Service status\n</code></pre>"},{"location":"linux/linux-questions/#common-interview-traps","title":"Common Interview Traps","text":""},{"location":"linux/linux-questions/#avoid-these-mistakes","title":"\u274c Avoid These Mistakes","text":"<p>Trap 1: \"I'd restart the server\"</p> <ul> <li>\u2705 Better: Show systematic troubleshooting first</li> </ul> <p>Trap 2: Wrong signals</p> <ul> <li>\u274c \"SIGINT pauses processes\"</li> <li>\u2705 SIGSTOP/SIGTSTP pause; SIGINT terminates</li> </ul> <p>Trap 3: Vague answers</p> <ul> <li>\u274c \"I'd check the logs\"</li> <li>\u2705 \"I'd check application logs with <code>journalctl -u service -f</code> and kernel messages with <code>dmesg</code>\"</li> </ul> <p>Trap 4: Forgetting permissions</p> <ul> <li>Many commands need sudo: ss -p, lsof, strace, tcpdump</li> <li>Mention this in answers</li> </ul> <p>Trap 5: Tool confusion</p> <ul> <li>\u274c \"netstat is better than ss\"</li> <li>\u2705 ss is faster and more powerful</li> </ul>"},{"location":"linux/linux-questions/#communication-tips","title":"Communication Tips","text":""},{"location":"linux/linux-questions/#structure-your-answers","title":"Structure Your Answers","text":"<ol> <li>Acknowledge: \"That's a good question about...\"</li> <li>State approach: \"I'd begin by checking...\"</li> <li>Show systematic thinking: \"First... then... finally...\"</li> <li>Mention trade-offs: \"This approach is fast but less detailed\"</li> <li>Admit uncertainty: \"I'm not certain, but I believe...\" is better than guessing</li> </ol>"},{"location":"linux/linux-questions/#think-out-loud","title":"Think Out Loud","text":"<ul> <li>\"I'm considering whether this is a network or application issue...\"</li> <li>\"Let me work through the TCP state machine...\"</li> <li>\"That's interesting, I haven't seen this exact scenario, but I'd approach it by...\"</li> </ul>"},{"location":"linux/linux-questions/#ask-clarifying-questions","title":"Ask Clarifying Questions","text":"<ul> <li>\"Is this a production system where I need to avoid service disruption?\"</li> <li>\"Do I have root access?\"</li> <li>\"Are there any monitoring tools already in place?\"</li> <li>\"What's the typical load on this system?\"</li> </ul>"},{"location":"linux/linux-questions/#key-concepts-summary","title":"Key Concepts Summary","text":""},{"location":"linux/linux-questions/#inodes","title":"Inodes","text":"<ul> <li>Store metadata (permissions, timestamps, size, pointers to data)</li> <li>Do NOT store filename or file content</li> <li>Filename \u2192 Directory Entry \u2192 Inode \u2192 Data Blocks</li> <li>Running out of inodes = can't create files despite free space</li> <li>Check with: <code>df -i</code></li> <li>View with: <code>ls -i</code></li> </ul>"},{"location":"linux/linux-questions/#file-deletion","title":"File Deletion","text":"<ul> <li><code>rm</code> calls <code>unlink()</code> system call</li> <li>Removes directory entry, decrements inode link count</li> <li>Data deleted when link count = 0 AND no processes have file open</li> <li>Data not immediately overwritten (file recovery possible)</li> </ul>"},{"location":"linux/linux-questions/#hard-links-vs-symlinks","title":"Hard Links vs Symlinks","text":"<ul> <li>Hard: Same inode, survives target deletion, same filesystem only</li> <li>Symlink: Own inode with path string, breaks if target deleted, cross-filesystem OK</li> </ul>"},{"location":"linux/linux-questions/#process-states_1","title":"Process States","text":"<ul> <li>R: Running/runnable</li> <li>S: Sleeping (interruptible)</li> <li>D: Sleeping (uninterruptible) - CANNOT BE KILLED</li> <li>Z: Zombie (already dead, waiting for parent to reap)</li> <li>T: Stopped (SIGSTOP/SIGTSTP)</li> </ul>"},{"location":"linux/linux-questions/#signals_2","title":"Signals","text":"<ul> <li>SIGTERM (15): Graceful shutdown (catchable, default)</li> <li>SIGKILL (9): Force kill (uncatchable)</li> <li>SIGSTOP (19): Pause (uncatchable)</li> <li>SIGCONT (18): Resume</li> <li>SIGHUP (1): Hangup/reload config</li> <li>SIGINT (2): Interrupt (Ctrl+C)</li> <li>SIGTSTP (20): Stop (Ctrl+Z, catchable)</li> </ul>"},{"location":"linux/linux-questions/#tcp-states","title":"TCP States","text":"<ul> <li>LISTEN: Waiting for connections</li> <li>SYN-SENT/SYN-RECEIVED: Handshake in progress</li> <li>ESTABLISHED: Active connection</li> <li>TIME-WAIT: Connection closed, waiting 2MSL for stray packets</li> <li>CLOSE-WAIT: Remote closed, local hasn't closed yet (app issue if many)</li> </ul>"},{"location":"linux/linux-questions/#tcp-vs-udp_1","title":"TCP vs UDP","text":"<ul> <li>TCP: Reliable, connection-oriented, retransmits lost packets, higher overhead</li> <li>UDP: Unreliable, connectionless, no retransmission, lower latency, less overhead</li> <li>TCP use: HTTP, SSH, file transfer (need reliability)</li> <li>UDP use: DNS, VoIP, streaming, gaming (need speed)</li> </ul>"},{"location":"linux/linux-questions/#netstat-vs-ss_1","title":"netstat vs ss","text":"<ul> <li>ss: Faster (netlink), more powerful filtering, detailed TCP info, modern</li> <li>netstat: Slower (/proc), basic info, legacy, deprecated</li> </ul>"},{"location":"linux/linux-questions/#disk-space-issues_1","title":"Disk Space Issues","text":"<ol> <li>Deleted files open: <code>lsof +L1</code></li> <li>Inode exhaustion: <code>df -i</code></li> <li>Reserved blocks: <code>tune2fs -l</code></li> <li>Hidden mounts: <code>umount</code> and check</li> </ol>"},{"location":"linux/linux-questions/#connection-reset","title":"Connection Reset","text":"<ul> <li>Application: RST mid-connection, logs show errors, many CLOSE-WAIT</li> <li>Firewall: RST after SYN, iptables counters increasing</li> <li>Connection tracking: nf_conntrack_count near max, dmesg warnings</li> <li>Kernel limits: netstat -s shows drops, file descriptor exhaustion</li> </ul>"},{"location":"linux/linux-questions/#practice-scenarios","title":"Practice Scenarios","text":""},{"location":"linux/linux-questions/#scenario-1-mysterious-disk-usage","title":"Scenario 1: Mysterious Disk Usage","text":"<pre><code>Problem: Server reports 95% disk usage, but du -sh / shows only 60% used\n\nYour approach:\n1. Check for deleted files still open: lsof +L1\n2. Check inode usage: df -i\n3. Compare df vs du output\n4. Check for hidden mounts\n5. Look for large logs being rotated but held open\n\nExpected answer: Identify root cause and explain recovery steps\n</code></pre>"},{"location":"linux/linux-questions/#scenario-2-unkillable-process","title":"Scenario 2: Unkillable Process","text":"<pre><code>Problem: Process consuming 100% CPU, won't respond to kill -9\n\nYour approach:\n1. Check process state: ps aux | grep PID\n2. If state is D: investigate I/O (iostat, lsof -p PID, /proc/PID/stack)\n3. If state is not D: verify you're killing correct PID, check if zombie\n4. Explain why D state can't be killed\n5. Propose solutions based on root cause\n\nExpected answer: Systematic diagnosis, understand kernel vs userspace\n</code></pre>"},{"location":"linux/linux-questions/#scenario-3-intermittent-connection-failures","title":"Scenario 3: Intermittent Connection Failures","text":"<pre><code>Problem: Web app occasionally returns \"Connection reset by peer\"\n\nYour approach:\n1. Capture RST packets: tcpdump\n2. Check connection tracking: nf_conntrack_count vs max\n3. Check application logs\n4. Use ss to check TCP health: bytes_retrans, socket states\n5. Check firewall rules: iptables -L -n -v\n6. Check kernel limits: netstat -s, ulimit\n\nExpected answer: Distinguish between app, firewall, and kernel causes\n</code></pre>"},{"location":"linux/linux-questions/#scenario-4-slow-file-transfer","title":"Scenario 4: Slow File Transfer","text":"<pre><code>Problem: scp transfer between servers is very slow despite high bandwidth\n\nYour approach:\n1. Check network basics: ping, traceroute\n2. Check interface stats: ip -s link, ethtool\n3. Check TCP performance: ss -ti for RTT, cwnd, retransmissions\n4. Test throughput: iperf3\n5. Check for packet loss: netstat -s | grep retrans\n6. Consider TCP tuning, MTU issues, SSH cipher overhead\n\nExpected answer: Layer-by-layer network troubleshooting\n</code></pre>"},{"location":"linux/linux-questions/#mongodb-specific-context","title":"MongoDB-Specific Context","text":""},{"location":"linux/linux-questions/#what-mongodb-values","title":"What MongoDB Values","text":"<p>Based on their engineering principles:</p> <p>1. Resilience</p> <ul> <li>Think about failure modes</li> <li>How would you monitor this?</li> <li>What happens when it breaks?</li> <li>\"Design for failure\" mentality</li> </ul> <p>2. Operational Excellence</p> <ul> <li>Automation over manual intervention</li> <li>Observability and debugging</li> <li>Learning from incidents</li> </ul> <p>3. Systematic Thinking</p> <ul> <li>Structured troubleshooting approach</li> <li>Root cause analysis</li> <li>Reproducible investigations</li> </ul>"},{"location":"linux/linux-questions/#during-interview","title":"During Interview","text":"<p>Show operational thinking:</p> <ul> <li>\"I'd want to set up monitoring for this metric...\"</li> <li>\"To prevent this in future, I'd implement...\"</li> <li>\"This would let me debug issues without impacting users...\"</li> </ul> <p>Consider distributed systems:</p> <ul> <li>\"In a distributed environment, I'd also check...\"</li> <li>\"Network partitions could cause...\"</li> <li>\"Eventual consistency means...\"</li> </ul> <p>Focus on reliability:</p> <ul> <li>\"The safest approach would be...\"</li> <li>\"To avoid downtime, I'd first...\"</li> <li>\"This has lower risk because...\"</li> </ul>"},{"location":"linux/linux-questions/#day-before-checklist","title":"Day-Before Checklist","text":""},{"location":"linux/linux-questions/#mental-preparation","title":"Mental Preparation","text":"<p>Remember:</p> <ul> <li>Partial answers with reasoning &gt; wrong confident answers</li> <li>It's OK to say \"I'm not sure, but here's how I'd investigate...\"</li> <li>Think out loud - interviewers want to see your process</li> <li>Ask clarifying questions - shows thoroughness</li> <li>Communication matters as much as technical knowledge</li> </ul> <p>Get Good Sleep:</p> <ul> <li>This interview rewards clear thinking over memorization</li> <li>Being well-rested helps with systematic reasoning</li> <li>Don't cram the night before</li> </ul>"},{"location":"linux/linux-questions/#quick-reference-most-important-commands","title":"Quick Reference - Most Important Commands","text":""},{"location":"linux/linux-questions/#the-top-20-you-must-know","title":"The \"Top 20\" You Must Know","text":"<pre><code># Process management\nps aux --sort=-%cpu\ntop / htop\nkill -TERM PID\nkill -STOP PID\n/proc/PID/status\n\n# File system\ndf -h / df -i\ndu -sh /*\nlsof +L1\nls -i\nstat filename\n\n# Networking\nss -tulnp\nss -ti\nping / traceroute\ntcpdump -i any port 80\nip addr show\n\n# Troubleshooting\ndmesg | tail\njournalctl -xe\nstrace -c -p PID\niostat -x 1\nvmstat 1\n</code></pre>"},{"location":"linux/linux-questions/#quick-answers-to-common-questions","title":"Quick Answers to Common Questions","text":"<p>\"Why can't I create files despite free space?\" \u2192 Check <code>df -i</code> for inode exhaustion</p> <p>\"Why can't I kill this process?\" \u2192 Check state with <code>ps aux | grep PID</code>. If D state, it's in uninterruptible I/O</p> <p>\"What's using all my disk space?\" \u2192 Check <code>lsof +L1</code> for deleted but open files</p> <p>\"Connections keep resetting\" \u2192 Check connection tracking: <code>cat /proc/sys/net/netfilter/nf_conntrack_count</code></p> <p>\"How do I see what a process is doing?\" \u2192 <code>strace -c -p PID</code> for syscalls, <code>lsof -p PID</code> for files, <code>/proc/PID/status</code> for state</p> <p>\"Process won't respond to SIGTERM\" \u2192 Escalate to <code>kill -KILL PID</code>, unless D state (then fix I/O issue)</p> <p>\"Network is slow\" \u2192 Check with <code>ss -ti</code> for retransmissions and RTT, <code>iostat</code> for I/O wait</p> <p>\"Too many connections in TIME-WAIT\" \u2192 Normal for busy servers (2MSL timeout), tune <code>tcp_tw_reuse</code> if needed</p>"},{"location":"linux/linux-questions/#final-tips","title":"Final Tips","text":""},{"location":"linux/linux-questions/#what-interviewers-look-for","title":"What Interviewers Look For","text":"<p>1. Structured Thinking</p> <ul> <li>Not jumping to conclusions</li> <li>Systematic elimination of causes</li> <li>Layer-by-layer approach</li> </ul> <p>2. Practical Knowledge</p> <ul> <li>Real commands, not just theory</li> <li>Understanding when to use which tool</li> <li>Edge cases and failure modes</li> </ul> <p>3. Communication</p> <ul> <li>Explaining thought process</li> <li>Acknowledging uncertainty</li> <li>Asking good questions</li> </ul> <p>4. Operational Mindset</p> <ul> <li>Impact on production</li> <li>Monitoring and prevention</li> <li>Automation opportunities</li> </ul>"},{"location":"linux/linux-questions/#red-flags-to-avoid","title":"Red Flags to Avoid","text":"<ul> <li>\u274c Guessing without admitting uncertainty</li> <li>\u274c Memorized answers without understanding</li> <li>\u274c Ignoring edge cases</li> <li>\u274c Forgetting to mention need for sudo/root</li> <li>\u274c Vague answers (\"check the logs\" without specifics)</li> <li>\u274c Immediate restart without investigation</li> </ul>"},{"location":"linux/linux-questions/#green-flags-to-show","title":"Green Flags to Show","text":"<ul> <li>\u2705 Structured troubleshooting approach</li> <li>\u2705 Multiple solution approaches</li> <li>\u2705 Awareness of trade-offs</li> <li>\u2705 Thinking about prevention</li> <li>\u2705 Clear communication</li> <li>\u2705 Honest about gaps in knowledge</li> </ul>"},{"location":"linux/linux-questions/#good-luck","title":"Good Luck!","text":"<p>Remember: This interview is about how you think, not just what you know.</p> <ul> <li>Stay calm and systematic</li> <li>Think out loud</li> <li>Ask clarifying questions</li> <li>Acknowledge when you're uncertain</li> <li>Show your reasoning process</li> </ul> <p>You've got this! \ud83d\ude80</p>"},{"location":"linux/linux-troubleshooting/","title":"Linux SRE Troubleshooting Study Sheet","text":""},{"location":"linux/linux-troubleshooting/#1-linux-boot-process-from-power-on-to-login-prompt","title":"1. Linux Boot Process - From Power On to Login Prompt","text":"<p>Boot Sequence:</p> <ol> <li>BIOS/UEFI - Hardware initialization, POST (Power-On Self-Test)</li> <li>Bootloader (GRUB) - Loads kernel from disk</li> <li>Kernel Initialization - Memory management, device drivers</li> <li>Init Process (PID 1) - systemd/SysV init starts</li> <li>System Services - Network, logging, etc.</li> <li>Display Manager - Login prompt appears</li> </ol> <p>Key Files:</p> <ul> <li><code>/boot/grub/grub.cfg</code> - Bootloader configuration</li> <li><code>/etc/systemd/system/</code> - Service definitions</li> <li><code>/var/log/boot.log</code> - Boot messages</li> </ul>"},{"location":"linux/linux-troubleshooting/#2-what-happens-when-you-type-ls","title":"2. What Happens When You Type <code>ls</code>","text":"<p>Process Flow:</p> <ol> <li>Shell parsing - <code>getline()</code> reads input, <code>strtok()</code> tokenizes</li> <li>Alias check - Shell checks if <code>ls</code> is an alias/builtin</li> <li>PATH lookup - Shell searches PATH directories for <code>ls</code> binary</li> <li>Process creation - <code>fork()</code> creates child process (returns 0 to child, PID to parent)</li> <li>Program execution - <code>execve()</code> gives child new address space</li> <li>Directory reading - <code>ls</code> reads filesystem inodes</li> <li>Process termination - <code>_exit(0)</code> called, kernel frees resources</li> </ol> <p>Debug command: <code>strace ls</code> to see system calls</p>"},{"location":"linux/linux-troubleshooting/#3-linux-inodes","title":"3. Linux Inodes","text":"<p>Definition: Data structure storing file/directory metadata</p> <p>Inode contains:</p> <ul> <li>File permissions and ownership</li> <li>File size and timestamps</li> <li>Pointers to data blocks</li> <li>Link count</li> </ul> <p>Commands:</p> <ul> <li><code>ls -i</code> - Show inode numbers</li> <li><code>stat filename</code> - Display inode information</li> <li><code>df -i</code> - Show inode usage</li> </ul>"},{"location":"linux/linux-troubleshooting/#4-crash-vs-panic","title":"4. Crash vs Panic","text":"Crash Panic Hardware/OS initiated Application initiated Memory access violations Calls <code>abort()</code> function SIGSEGV, SIGBUS, SIGILL Controlled shutdown <p>Common crash signals:</p> <ul> <li>SIGSEGV - Segmentation fault</li> <li>SIGBUS - Bus error  </li> <li>SIGILL - Illegal instruction</li> </ul> <p>Tools: <code>gdb</code>, signal handlers, core dumps</p>"},{"location":"linux/linux-troubleshooting/#5-proc-filesystem","title":"5. /proc Filesystem","text":"<p>Virtual filesystem containing runtime system information</p> <p>Key directories/files:</p> <ul> <li><code>/proc/[PID]/</code> - Process-specific information</li> <li><code>/proc/self/</code> - Current process</li> <li><code>/proc/[PID]/maps</code> - Memory mappings</li> <li><code>/proc/[PID]/cmdline</code> - Command line arguments</li> <li><code>/proc/[PID]/environ</code> - Environment variables</li> <li><code>/proc/[PID]/fd/</code> - File descriptors</li> <li><code>/proc/locks</code> - File locks</li> <li><code>/proc/sys/fs/file-nr</code> - Open file statistics</li> <li><code>/proc/sys/vm/</code> - Virtual memory tuning</li> </ul>"},{"location":"linux/linux-troubleshooting/#6-filesystem-full-but-df-shows-space","title":"6. Filesystem Full but df Shows Space","text":"<p>Troubleshooting steps:</p> <ol> <li>Check inodes: <code>df -i</code> (look for 0 IFree)</li> <li>Check deleted files in use: <code>lsof | grep deleted</code></li> <li>Restart processes holding deleted files</li> <li>Check for large files: <code>du -sh /*</code></li> </ol> <p>Common causes:</p> <ul> <li>Inode exhaustion</li> <li>Deleted files still open by processes</li> <li>Reserved blocks for root</li> </ul>"},{"location":"linux/linux-troubleshooting/#7-linux-performance-tools","title":"7. Linux Performance Tools","text":"<p>Essential monitoring tools:</p> <ol> <li>uptime - Load averages</li> <li>dmesg | tail - Kernel messages</li> <li>vmstat 1 - Virtual memory statistics</li> <li>mpstat -P ALL 1 - CPU usage per core</li> <li>pidstat 1 - Process statistics</li> <li>iostat -xz 1 - I/O statistics</li> <li>free -m - Memory usage</li> <li>sar -n DEV 1 - Network device statistics</li> <li>sar -n TCP,ETCP 1 - TCP statistics</li> <li>top/htop - Process monitoring</li> </ol>"},{"location":"linux/linux-troubleshooting/#8-linux-filesystem-types","title":"8. Linux Filesystem Types","text":"<p>Common filesystems:</p> <ul> <li>EXT4 - Default Linux filesystem</li> <li>XFS - High-performance journaling</li> <li>BTRFS - Copy-on-write with snapshots</li> <li>ZFS - Advanced features, checksumming</li> <li>NTFS - Windows compatibility</li> </ul> <p>Commands:</p> <ul> <li><code>mount</code> - Show mounted filesystems</li> <li><code>lsblk</code> - List block devices</li> <li><code>fsck</code> - Filesystem check</li> </ul>"},{"location":"linux/linux-troubleshooting/#9-kernel-space-vs-user-space","title":"9. Kernel Space vs User Space","text":"<p>User Space:</p> <ul> <li>Applications run here</li> <li>Limited access to hardware</li> <li>Uses system calls to access kernel</li> </ul> <p>Kernel Space:</p> <ul> <li>Operating system kernel</li> <li>Direct hardware access</li> <li>Memory protection enforced</li> </ul> <p>Communication: System calls bridge user/kernel space</p> <p>Libraries: libc provides system call wrappers</p>"},{"location":"linux/linux-troubleshooting/#10-high-io-troubleshooting","title":"10. High I/O Troubleshooting","text":"<p>Investigation steps:</p> <ol> <li>Identify source: <code>iotop</code>, <code>iostat -x 1</code></li> <li>Check disk utilization: <code>iostat -x 1</code> (look for %util)</li> <li>Find processes: <code>iotop</code>, <code>pidstat -d 1</code></li> <li>Check disk health: <code>smartctl -a /dev/sda</code></li> <li>Analyze I/O patterns: <code>blktrace</code></li> </ol> <p>Key metrics:</p> <ul> <li>IOPS - I/O operations per second</li> <li>Throughput - MB/s</li> <li>Latency - Response time</li> <li>Queue depth - Pending I/O requests</li> </ul>"},{"location":"linux/linux-troubleshooting/#11-processes-vs-threads","title":"11. Processes vs Threads","text":"Processes Threads Independent memory space Shared memory space Higher creation overhead Lower creation overhead Inter-process communication needed Direct memory sharing Isolated execution Can interfere with each other <p>Process Control Block (PCB) contains:</p> <ul> <li>Process ID (PID)</li> <li>Memory pointers</li> <li>CPU registers</li> <li>I/O status</li> </ul>"},{"location":"linux/linux-troubleshooting/#12-kernel-memory-management","title":"12. Kernel Memory Management","text":"<p>Key concepts:</p> <ul> <li>Virtual Memory - Abstraction layer over physical memory</li> <li>Page Tables - Virtual to physical address mapping</li> <li>Memory Zones - DMA, Normal, HighMem</li> <li>Slab Allocator - Kernel object caching</li> <li>Page Cache - File system caching</li> </ul> <p>Commands:</p> <ul> <li><code>/proc/meminfo</code> - Memory statistics</li> <li><code>free -m</code> - Memory usage</li> <li><code>/proc/slabinfo</code> - Slab cache info</li> </ul>"},{"location":"linux/linux-troubleshooting/#13-process-states","title":"13. Process States","text":"<p>Task states:</p> <ul> <li>TASK_RUNNING (R) - Executing or runnable</li> <li>TASK_INTERRUPTIBLE (S) - Sleeping, waiting for signal</li> <li>TASK_UNINTERRUPTIBLE (D) - Deep sleep, usually I/O wait</li> <li>TASK_STOPPED (T) - Stopped by signal</li> <li>TASK_ZOMBIE (Z) - Terminated, awaiting parent cleanup</li> </ul> <p>Commands:</p> <ul> <li><code>ps aux</code> - Show process states</li> <li><code>top</code> - Real-time process monitoring</li> </ul>"},{"location":"linux/linux-troubleshooting/#14-linux-concurrency-and-race-conditions","title":"14. Linux Concurrency and Race Conditions","text":"<p>Concurrency mechanisms:</p> <ul> <li>Mutexes - Mutual exclusion locks</li> <li>Semaphores - Counting locks</li> <li>Spinlocks - Busy-wait locks</li> <li>RCU - Read-Copy-Update</li> </ul> <p>Race conditions occur when multiple threads access shared data simultaneously</p> <p>Prevention: Proper locking, atomic operations</p>"},{"location":"linux/linux-troubleshooting/#15-stack-vs-heap-memory","title":"15. Stack vs Heap Memory","text":"Stack Heap Automatic allocation Manual allocation LIFO structure Random access Fast allocation/deallocation Slower allocation Limited size Large size Local variables Dynamic allocation <p>Stack: Function calls, local variables</p> <p>Heap: Dynamic memory allocation (<code>malloc</code>, <code>new</code>)</p>"},{"location":"linux/linux-troubleshooting/#16-memory-leaks","title":"16. Memory Leaks","text":"<p>Types:</p> <ol> <li>Classic leak - Unreachable memory not freed</li> <li>Semantic leak - Reachable but unnecessary memory</li> </ol> <p>Detection tools:</p> <ul> <li><code>valgrind</code> - Memory error detector</li> <li><code>mtrace</code> - GNU malloc debugging</li> <li><code>AddressSanitizer</code> - Google's memory error detector</li> </ul> <p>Prevention: RAII, smart pointers, garbage collection</p>"},{"location":"linux/linux-troubleshooting/#17-linux-interrupt-handling","title":"17. Linux Interrupt Handling","text":"<p>Interrupt processing:</p> <ol> <li>Hardware interrupt - Device signals CPU</li> <li>Context save - Current process state saved</li> <li>Interrupt handler - Kernel executes ISR</li> <li>Context restore - Return to interrupted process</li> </ol> <p>Types:</p> <ul> <li>Hardware interrupts - External devices</li> <li>Software interrupts - System calls, exceptions</li> </ul> <p>Commands:</p> <ul> <li><code>/proc/interrupts</code> - Show interrupt statistics</li> <li><code>cat /proc/stat</code> - System statistics</li> </ul>"},{"location":"linux/linux-troubleshooting/#18-load-average","title":"18. Load Average","text":"<p>Definition: Average number of processes that are either:</p> <ul> <li>Running on CPU</li> <li>Waiting for CPU</li> <li>Waiting for I/O to complete</li> </ul> <p>Time periods: 1, 5, and 15 minutes</p> <p>Interpretation:</p> <ul> <li>&lt; 1.0 - No wait time</li> <li>= 1.0 - System fully utilized</li> <li>&gt; 1.0 - Processes waiting</li> </ul> <p>Commands: <code>uptime</code>, <code>w</code>, <code>top</code></p>"},{"location":"linux/linux-troubleshooting/#19-what-happens-when-you-curl-a-website","title":"19. What Happens When You curl a Website","text":"<p>Network flow:</p> <ol> <li>DNS lookup - Resolve domain to IP</li> <li>TCP connection - 3-way handshake</li> <li>TLS handshake - SSL/TLS negotiation (HTTPS)</li> <li>HTTP request - Send GET/POST request</li> <li>Server processing - Web server handles request</li> <li>HTTP response - Server sends response</li> <li>Connection close - TCP teardown</li> </ol> <p>Tools for debugging:</p> <ul> <li><code>nslookup/dig</code> - DNS lookup</li> <li><code>tcpdump</code> - Packet capture</li> <li><code>netstat</code> - Network connections</li> <li><code>curl -v</code> - Verbose output</li> </ul>"},{"location":"linux/linux-troubleshooting/#20-production-debugging","title":"20. Production Debugging","text":""},{"location":"linux/linux-troubleshooting/#core-dumps-analysis","title":"Core Dumps Analysis","text":"<p>What is a Core Dump:</p> <p>A core dump is a snapshot of a process's memory and CPU state when it crashes, used for post-mortem debugging.</p> <p>Enabling Core Dumps:</p> <pre><code># Check current limits\nulimit -c\n\n# Enable unlimited core dumps\nulimit -c unlimited\n\n# Set system-wide core dump pattern\necho '/var/core/core.%e.%p.%t' &gt; /proc/sys/kernel/core_pattern\n\n# Enable core dumps for systemd services\necho 'DefaultLimitCORE=infinity' &gt;&gt; /etc/systemd/system.conf\n</code></pre> <p>Core Dump Analysis with GDB:</p> <pre><code># Generate core dump from running process\ngcore &lt;PID&gt;\n\n# Analyze core dump\ngdb /path/to/binary /path/to/core.file\n\n# Key GDB commands for debugging:\n(gdb) bt              # Backtrace - show call stack\n(gdb) bt full         # Full backtrace with local variables\n(gdb) info registers  # Show CPU register values\n(gdb) info threads    # Show all threads\n(gdb) thread 2        # Switch to thread 2\n(gdb) print variable  # Print variable value\n(gdb) x/10i $pc      # Examine 10 instructions at program counter\n</code></pre> <p>Core Dump Analysis without GDB:</p> <pre><code># Use file command to verify core dump\nfile core.1234\n\n# Extract stack trace with addr2line\naddr2line -e /path/to/binary -f -C &lt; addresses.txt\n\n# Use objdump for disassembly\nobjdump -d /path/to/binary | grep -A10 -B10 &lt;address&gt;\n</code></pre>"},{"location":"linux/linux-troubleshooting/#memory-leak-detection","title":"Memory Leak Detection","text":"<p>Using Valgrind:</p> <pre><code># Detect memory leaks\nvalgrind --tool=memcheck --leak-check=full --show-leak-kinds=all ./program\n\n# Detailed leak detection with call stack\nvalgrind --tool=memcheck --leak-check=full --track-origins=yes ./program\n\n# Generate suppression file for known false positives\nvalgrind --gen-suppressions=all ./program 2&gt;&amp;1 | grep -A20 \"{\"\n</code></pre> <p>Using AddressSanitizer (ASan):</p> <pre><code># Compile with AddressSanitizer\ngcc -fsanitize=address -g -o program program.c\n\n# Run with additional options\nASAN_OPTIONS=detect_leaks=1:abort_on_error=1 ./program\n</code></pre> <p>Production Memory Analysis:</p> <pre><code># Monitor process memory usage over time\nwhile true; do\n    ps -o pid,vsz,rss,pmem,comm -p &lt;PID&gt;\n    sleep 60\ndone\n\n# Use pmap to analyze memory layout\npmap -x &lt;PID&gt;\n\n# Check for memory leaks in running process\ncat /proc/&lt;PID&gt;/smaps | grep -E \"(Size|Rss|Pss)\"\n\n# Monitor memory allocation patterns\necho 1 &gt; /proc/&lt;PID&gt;/clear_refs\n# Wait some time\ncat /proc/&lt;PID&gt;/smaps | awk '/^[0-9]/{print $1}' | while read addr; do\n    grep -A15 \"^$addr\" /proc/&lt;PID&gt;/smaps | grep Referenced\ndone\n</code></pre> <p>Heap Analysis Tools:</p> <pre><code># Use heaptrack for heap profiling\nheaptrack ./program\nheaptrack_gui heaptrack.program.&lt;PID&gt;.gz\n\n# Use massif (Valgrind tool) for heap profiling\nvalgrind --tool=massif ./program\nms_print massif.out.&lt;PID&gt;\n\n# Monitor malloc/free patterns with ltrace\nltrace -e malloc,free,realloc ./program\n</code></pre> <p>Memory Debugging in Production:</p> <pre><code># Check for OOM kills\ndmesg | grep -i \"killed process\"\njournalctl -u &lt;service&gt; | grep -i \"out of memory\"\n\n# Monitor memory pressure\ncat /proc/pressure/memory\n\n# Check memory cgroups limits\ncat /sys/fs/cgroup/memory/&lt;cgroup&gt;/memory.usage_in_bytes\ncat /sys/fs/cgroup/memory/&lt;cgroup&gt;/memory.limit_in_bytes\n\n# Use jemalloc for better memory tracking (if available)\nLD_PRELOAD=libjemalloc.so.2 MALLOC_CONF=prof:true ./program\n</code></pre> <p>Quick Memory Leak Detection:</p> <pre><code># Simple memory growth detection\nfunction check_memory_growth() {\n    local pid=$1\n    local baseline=$(ps -o rss= -p $pid)\n    sleep 300  # Wait 5 minutes\n    local current=$(ps -o rss= -p $pid)\n    local growth=$((current - baseline))\n    echo \"Memory growth: ${growth}KB in 5 minutes\"\n    [ $growth -gt 10240 ] &amp;&amp; echo \"WARNING: Potential memory leak detected\"\n}\n</code></pre>"},{"location":"linux/linux-troubleshooting/#quick-reference-commands","title":"Quick Reference Commands","text":"<p>System Info:</p> <pre><code>uname -a                 # System information\ncat /etc/os-release     # OS version\nlscpu                   # CPU information\nlsmem                   # Memory information\n</code></pre> <p>Process Management:</p> <pre><code>ps aux                  # All processes\npgrep -f pattern        # Find processes by name\nkill -9 PID            # Force kill process\nnohup command &amp;        # Run command in background\n</code></pre> <p>File Operations:</p> <pre><code>find / -name filename   # Find files\nlsof filename          # Show processes using file\nfuser -v filename      # Show processes using file\n</code></pre> <p>Network:</p> <pre><code>ss -tulpn              # Show listening ports\nnetstat -i             # Network interfaces\niftop                  # Network traffic monitor\n</code></pre> <p>Disk/Filesystem:</p> <pre><code>lsblk                  # List block devices\nmount                  # Show mounted filesystems\ndu -sh /*              # Directory sizes\n</code></pre>"},{"location":"terminology/","title":"Common Terminology","text":"<ul> <li>Manual</li> <li>Repetitive</li> <li>Automatable  </li> </ul> <p>Overhead is often work not directly tied to running a production service, and includes tasks like team meetings, setting and grading goals,19 snippets,20 and HR paperwork.  </p> <p>Carefully define quantitative measurement of a service/system generally of keys metrics, usually via observability tools. </p> <p>Once a system has been measured certain benchmarks for target ranges can be determined for a service level given the SLIs. </p> <p>An explicit/implicit contract with a systems users that includes consequences of meeting (or missing) the SLO they contain. </p> <p>Traffic  A measurement of how much demand is being placed on a system, measured in a high-level system-specific metric. Usually denoted for APIs as request per second (RPS). </p> <p></p> <p>Latency  The time it takes to service a request. Difference between a successful request HTTP 200 vs non successful request latencies !HTTP 200 (400s, 500s).</p> <p></p> <p>Saturation  How much load is on your system. A measure of your systems fraction, emphasizing the resources that are most constrained (e.g. in a memory constrained system, show memory, etc...).</p> <p></p> <p>Errors  The rate of which requests fails, either explicitly (HTTP 500), implicitly (an HTTP 200, but with bad content). Generally total availability can be determined from 1/error rate.</p> <p></p> <p></p> <p>Key Results The yard stick of how to measure progress to the objectives. Specific,time-bound, aggressive yet realistic. \"3-5 milestones of how you will accomplish it\". </p> <p></p>"},{"location":"terminology/#toil","title":"Toil","text":""},{"location":"terminology/#overhead","title":"Overhead","text":""},{"location":"terminology/#service-level-indicators","title":"Service Level Indicators","text":""},{"location":"terminology/#service-level-objectives","title":"Service Level Objectives","text":""},{"location":"terminology/#service-level-agreements","title":"Service Level Agreements","text":""},{"location":"terminology/#four-golden-signals","title":"Four Golden Signals","text":""},{"location":"terminology/#objectives-and-key-results-okrs","title":"Objectives and Key Results (OKRs)","text":"<p>Objectives Simply is what is to be achieved. Significant, concrete, and action oriented. \"What you want to accomplish\"</p>"}]}